[{"title":"在Android Studio中发布Library到jCenter本地仓库","date":"2017-01-19T05:53:00.000Z","path":"2017/01/19/2017-01-19-distribute-android-library-to-local-jCenter/","text":"引论在在Android Studio中发布Library到jCenter公共仓库中，我们知道了123repositories &#123; jcenter() &#125; 是如何工作的，也知道了如何向全球公共仓库提交自己的Library。有时我们在添加依赖时还可能添加jCenter之外的仓库，如：1234repositories &#123; jcenter() maven &#123; url \"http://localhost:8081/artifactory/libs-release-local\" &#125; &#125; 在此处url是一个本地仓库，也可能是网络的某个位置。就好像github是一个网上的git repo，本地开发环境也有一个完整的git repo一样，jCenter就是这样一个最大的网络repo，同时我们可以利用Bintray提供的开源应用artifactory来搭建本地或团队使用的repo。下图是jFrog BinTray官方提供的artifactory架构图： 可以看出，通过artifactory可以与非常多的开发工具进行集成，构建最优的开发流程，与内部用户权限管理整合，提供完整的应用包分发管理。还可以配置同步到jCenter，这也是BinTray设计artifactory的重要一环。 还有其它的库管理应用，因为我们的开发与jCenter尝试整合，就不考虑其它的了，给出列表供参考。Repository Management Tools 搭建artifactoryJDKartifactory本身是一个开源的Java EE应用，确保机器上有JDK运行，推荐使用最新的JDK8，JDK7官方已不再更新，artifactory也对JDK7支持不好。1234➜ Downloads java -versionjava version \"1.8.0_60\"Java(TM) SE Runtime Environment (build 1.8.0_60-b27)Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode) artifactory下载Artifactory后解压zip包，可以直接运行，已包含Tomcat容器。1➜ Downloads ./artifactory-oss-4.1.3/bin/artifactory.sh 看到123############################################################## Artifactory successfully started (4.930 seconds) ############################################################## Done，本地的artifactory已经运行起来了，浏览器打开http://localhost:8081/artifactory/默认的用户名密码是admin/password，可以进行管理，现在先不配置，继续我们的上传进程。 发布配置Gradle在Project/build.gradle下添加：123456buildscript &#123; dependencies &#123; //添加引用位置 classpath \"org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1\" &#125;&#125; 在Library/build.gradle中添加：123456789101112131415161718192021222324252627282930313233343536373839404142//plugin要添加到apply plugin: 'com.android.library'之后//添加上传所需的插件apply plugin: 'com.jfrog.artifactory'apply plugin: 'maven-publish'//定义包名和版本号def packageName = 'com.geek.dev'def libraryVersion = '1.0.2'publishing &#123; publications &#123; aar(MavenPublication) &#123; groupId packageName version = libraryVersion artifactId project.getName() // Tell maven to prepare the generated \"*.aar\" file for publishing artifact(\"$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar\") &#125; &#125;&#125;artifactory &#123; contextUrl = 'http://localhost:8081/artifactory' publish &#123; repository &#123; // The Artifactory repository key to publish to repoKey = 'libs-release-local' username = \"admin\" password = \"password\" &#125; defaults &#123; // Tell the Artifactory Plugin which artifacts should be published to Artifactory. publications('aar') publishArtifacts = true // Properties to be attached to the published artifacts. properties = ['qa.level': 'basic', 'dev.team': 'core'] // Publish generated POM files to Artifactory (true by default) publishPom = true &#125; &#125;&#125; 运行发布在Terminal Panel中运行：1./gradle assembleRelease artifactoryPublish 看到发布结果：123456Deploying artifact: http://localhost:8081/artifactory/libs-release-local/com/geek/dev/weatherlib/1.0.2/weatherlib-1.0.2.aarDeploying artifact: http://localhost:8081/artifactory/libs-release-local/com/geek/dev/weatherlib/1.0.2/weatherlib-1.0.2.pomDeploying build descriptor to: http://localhost:8081/artifactory/api/buildBuild successfully deployed. Browse it in Artifactory under http://localhost:8081/artifactory/webapp/builds/WeatherLibrary/1445153016002/2015-10-18T15:23:35.938+0800/BUILD SUCCESSFUL 到http://localhost:8081/artifactory/里验证： 使用本地库在Project/build.gradle中添加本地库：1234567allprojects &#123; repositories &#123; jcenter() maven &#123; url \"http://localhost:8081/artifactory/libs-release-local\" &#125; &#125;&#125; 在Module/build.gradle中添加依赖，格式如上图：123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.0.1' compile(group: 'com.geek.dev', name: 'weatherlib', version: '1.0.2', ext: 'aar')&#125; 总结通过本文的介绍，可以掌握为自己或团队搭建本地库以及让如何使用，系统跑起来了，流程走通了，再进行深入细化，artifactory权限、服务器管理等等。由aar包引用到jcenter()，整个系列囊括了本地文件，网络公共库和本地库，可以将整个Android开发过程中的依赖管理理解的更加深刻，让开发过程变得越来越清晰，整个信息流向越来越透明。 Referenceshttps://www.jfrog.com/wp-content/uploads/2014/05/artifactory_overview_diagram.jpg distribute to maven centeral","tags":[{"name":"Andorid","slug":"Andorid","permalink":"https://yangbo.tech/tags/Andorid/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangbo.tech/tags/Gradle/"},{"name":"Andorid Studio","slug":"Andorid-Studio","permalink":"https://yangbo.tech/tags/Andorid-Studio/"}]},{"title":"使用Service worker实现加速/离线访问静态blog网站","date":"2017-01-15T12:59:00.000Z","path":"2017/01/15/2017-01-15-speedy-and-offline-site-by-service-worker/","text":"现在很流行基于Github page和markdown的静态blog，非常适合技术的思维和习惯，针对不同的语言都有一些优秀的静态blog系统出现，如Jekyll/Ruby，Pelican/Python，Hexo/NodeJs，由于静态内容的特性非常适合做缓存来加速页面的访问，就利用Service worker来实现加速，结果是除了PageSpeed，CDN这些常见的服务器和网络加速之外，通过客户端实现了更好的访问体验。 加速/离线访问只需三步 首页添加注册代码 12345&lt;script&gt;if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/sw.js');&#125;&lt;/script&gt; 复制代码 将https://alphayang.github.io/sw.js保存到你的网站根目录下 修改不缓存域名列表及离线状态页面 在你的sw.js中修改123456const ignoreFetch = [ /https?:\\/\\/cdn.bootcss.com\\//, /https?:\\/\\/static.duoshuo.com\\//, /https?:\\/\\/www.google-analytics.com\\//, /https?:\\/\\/dn-lbstatics.qbox.me\\//,]; 打开Chrome Dev Tools-&gt;Source，看看自己的blog都引用了哪些第三方资源，逐个加到忽略列表里。 在根目录下添加offline.html，在没有网络且缓存中也没有时使用，效果如下： 在根目录下添加offline.svg，在无网络时图片资源请求返回该文件。 加速效果首页加速后，网络请求从16降为1，加载时间从2.296s降为0.654s，得到了瞬间加载的结果。 基于webpagetest 查看测试结果 加速/离线原理探索什么是 Service worker 如上图，Service worker 是一种由Javascript编写的浏览器端代理脚本，位于你的浏览器和服务器之间。当一个页面注册了一个 Service worker，它就可以注册一系列事件处理器来响应如网络请求和消息推送这些事件。Service worker 可以被用来管理缓存，当响应一个网络请求时可以配置为返回缓存还是从网络获取。由于Service worker 是基于事件的，所以它只在处理这些事件的时候被调入内存，不用担心常驻内存占用资源导致系统变慢。 Service worker生命周期 Service worker 为网页添加一个类似于APP的生命周期，它只会响应系统事件，就算浏览器关闭时操作系统也可以唤醒Service worker，这点非常重要，让web app与native app的能力变得类似了。 Service worker在Register时会触发Install事件，在Install时可以用来预先获取和缓存应用所需的资源并设置每个文件的缓存策略。 一旦Service worker处于activated状态，就可以完全控制应用的资源，对网络请求进行检查，修改网络请求，从网络上获取并返回内容或是返回由已安装的Service worker预告获取并缓存好的资源，甚至还可以生成内容并返回给网络语法。 所有的这些都用户都是透明的，事实上，一个设计优秀的Service worker就像一个智能缓存系统，加强了网络和缓存功能，选择最优方式来响应网络请求，让应用更加稳定的运行，就算没有网络也没关系，因为你可以完全控制网络响应。 Service worker的控制从第二次页面访问开始在首次加载页面时，所有资源都是从网络载的，Service worker 在首次加载时不会获取控制网络响应，它只会在后续访问页面时起作用。 页面首次加载时完成install，并进入idle状态。 页面第二次加载时，进入activated状态，准备处理所有的事件，同时 浏览器会向服务器发送一个异步 请求来检查Service worker本身是否有新的版本，构成了Service worker的更新机制。 当Service worker处理完所有的事件后，进入idle状态，最终进入terminated状态资源被释放，当有新的事件发生时再度被调用。 特点 浏览器 Google Chrome，Firefox，Opera以及国内的各种双核浏览器都支持，但是 safari 不支持，那么在不支持的浏览器里Service worker不工作。 https 网站必须启用https来保证使用Service worker页面的安全性，开发时localhost默认认为是安全的。 non-block Service worker 中的 Javascript 代码必须是非阻塞的，因为 localStorage 是阻塞性，所以不应该在 Service Worker 代码中使用 localStorage。 单独的执行环境 Service worker运行在自己的全局环境中，通常也运行在自己单独的线程中。 没有绑定到特定页面 service work能控制它所加载的整个范围内的资源。 不能操作DOM 跟DOM所处的环境是相互隔离的。 没有浏览页面时也可以运行 接收系统事件，后台运行 事件驱动，需要时运行，不需要时就终止 按需执行，只在需要时加载到内存 可升级 执行时会异步获取最新的版本 实现加速/离线Cache网页缓存有很多，如HTTP缓存，localStorage，sessionStorage和cacheStorage都可以灵活搭配进行缓存，但操作太繁琐，直接使用更高级Service worker –本文的主人公。 添加Service worker入口在web app的首页添加以下代码12345&lt;script&gt;if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/sw.js');&#125;&lt;/script&gt; 如果浏览器支持serviceWorker就注册它，不支持还是正常浏览，没有Service worker所提供的增强功能。 Service worker控制范围：简单情况下，将sw.js放在网站的根目录下，这样Service worker可以控制网站所有的页面，，同理，如果把sw.js放在/my-app/sw.js那么它只能控制my-app目录下的页面。把sw.js放在/js/目录呢？更好的目录结构和范围控制呢？在注册时指定js位置并设置范围。1234567navigator.serviceWorker.register('/js/sw.js', &#123;scope: '/sw-test/'&#125;).then(function(registration) &#123; // Registration was successful console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;).catch(function(err) &#123; // registration failed :( console.log('ServiceWorker registration failed: ', err); &#125;); Service worker实现监听三个事件：12345self.addEventListener('install', onInstall);self.addEventListener('fetch', onFetch);self.addEventListener(\"activate\", onActivate); install12345678910111213141516171819//////////// Install//////////function onInstall(event) &#123; log('install event in progress.'); event.waitUntil(updateStaticCache());&#125;function updateStaticCache() &#123; return caches .open(cacheKey('offline')) .then((cache) =&gt; &#123; return cache.addAll(offlineResources); &#125;) .then(() =&gt; &#123; log('installation complete!'); &#125;);&#125; install时将所有符合缓存策略的资源进行缓存。 fetch12345678910111213141516171819////////// Fetch////////function onFetch(event) &#123; const request = event.request; if (shouldAlwaysFetch(request)) &#123; event.respondWith(networkedOrOffline(request)); return; &#125; if (shouldFetchAndCache(request)) &#123; event.respondWith(networkedOrCached(request)); return; &#125; event.respondWith(cachedOrNetworked(request));&#125;onFetch做为浏览器网络请求的代理，根据需要返回网络或缓存内容，如果获取了网络内容，返回网络请求时同时进行缓存操作。 activate1234567891011121314151617181920212223242526///////////// Activate///////////function onActivate(event) &#123; log('activate event in progress.'); event.waitUntil(removeOldCache());&#125;function removeOldCache() &#123; return caches .keys() .then((keys) =&gt; &#123; return Promise.all( // We return a promise that settles when all outdated caches are deleted. keys .filter((key) =&gt; &#123; return !key.startsWith(version); // Filter by keys that don't start with the latest version prefix. &#125;) .map((key) =&gt; &#123; return caches.delete(key); // Return a promise that's fulfilled when each outdated cache is deleted. &#125;) ); &#125;) .then(() =&gt; &#123; log('removeOldCache completed.'); &#125;);&#125; 在activate时根据version值来删除过期的缓存。 管理 Service worker特定网站 Google Chrome Developer Tools-&gt;Application-&gt;Service Workers， 在这里还有三个非常有用的复选框： Offline 模拟断网状态 Update on reload加载时更新 Bypass for network总是使用网络内容 Firefox 只有在Settings里有一个可以在HTTP环境中使用Service worker的选项，适应于调试，没有单独网站下的Service worker管理。 Opera及其它双核浏览器同Google Chrome如果看到多个相同范围内的多个Service worker，说明Service woker更新后，而原有Service worker还没有被terminated。 浏览器全局看看你的浏览器里都有哪些Service worker已经存在了 Google Chrome 在地址栏里输入：1chrome://serviceworker-internals/ 可以看到已经有24个Service worker了，在这里可以手动Start让它工作，也可以Unregister卸载掉。 Firefox 有两种方式进入Service worker管理界面来手动Start或unregister。 菜单栏，Tool-&gt;Web Developer-&gt;Service workers 地址栏中输入 1about:debugging#workers Opera及其它双核浏览器同Google Chrome 更多TODO: Service workers的更新需要手动编辑version，每次发布新文章时需要编辑。 使用AMP让页面渲染速度达到最高。 Ref linksService Worker Cookbook Is service worker ready? Chrome service worker status page Firefox service worker status page MS Edge service worker status page WebKit service worker status page","tags":[]},{"title":"Tango+Daydream，刀剑合璧的Android VR开发","date":"2017-01-03T06:48:00.000Z","path":"2017/01/03/2017-01-03-tango-with-daydream-is-coming/","text":"随着ASUS在CES2017上宣布了全球第一款同时具有Tango和Daydream两种能力的ZenFone AR，终于使得AR/VR/MR这些近来全球开发圈内超级热门的词汇可以让我们国内的Android开发者直接利用手中的Android Studio和方便入手的Android设备来进行虚拟开发的探索了！ 三种交互AR增强现实，人眼接受到的光线包括了现实的光和AR设备屏幕发出的光，通过人眼的处理能力进行合成，增强现实感。Phab 2 Pro就是一款AR设备，可以拍摄可爱的小猫或小狗跟小宝宝一起玩的照片而不用担心安全，因为小动物都是虚拟的。 VR虚拟现在，使用头盔或Cardboard完全遮挡住现实的光线，人眼只接受VR设备发出的光，跟现实完全隔离。Oculus Rift， PlayStation VR， Samsung Gear VR 以及 HTC Vive都属于此类设备。 MR混合现实，MR设备自身具有三维坐标感知能力，随着人的移动，虚拟物体的显示也随着变化。Hololens属于MR设备。 两大技术Tango（屠龙)正如2000年时Sumsung在SCH-V200手机上上添加了摄像头，手机开始了睁眼看世界的能力，现在Tango摄像头为手机添加了真实三维世界的感知能力。 简单的讲，Tango具有以下三大功能： Motion tracking: 我在哪里，空间位置 Area learning: 前边有什么，看到什么 Depth perception: 前边有多远 不论是使用ToF(Time of Flight)，通过传感器发出经调制的近红外光，遇物体后反射，传感器通过计算光线发射和反射时间差或相位差，来换算被拍摄景物的距离，以产生深度信息。 还是结构光计算，通过向检测空间内投射经过编码的激光光斑阵列，对空间进行标定并辅助计算三维空间位置。 所得到的如下图中的cloud point数据，可以看到此时共采集到了12464个带有XYZ三维坐标的点。 Daydream(倚天)目的是要让用户得到最好的虚拟体验，通过定义了一组最低的硬件运行效果标准以及为开发者提供易用的Daydream API，消除了导致用户眩晕的画面延迟，做到最高性价比的虚拟体验。 硬件Phab 2 Pro全球第一款消费级的Tango设备，使用骁龙652，4G内存和64G存储，重要的是国内版本和国外版本都具有完整的Tango功能。京东上可以直接下单，支持211的！缺点是作为普通手机使用，6.4寸屏幕太大，顔值也不够高，整体偏笨。Android感知三维世界的”眼睛”–Tango组件: 典型的应用场景: ZenFone AR全球第一款消费级的Tango+Daydream设备，使用骁龙821来保证用户得到Daydream体验，第一款Daydream手机Google Pixel和Asus Zenphone 3也使用的是骁龙821。由于Daydream Viewer现在兼容的手机尺寸是5.0到5.7寸屏，那么ZenFone AR搭配Android 7(Nougat)的5.7寸屏用起来应当是相当顺手的。 Tango开发首先，你需要一款Tango设备，因为还没有可以模拟Tango相关摄像头硬件的模拟器，上节中 Phab 2 Pro 是很不错的开发机！现在以Java API开发为例来进入Tango APP的开发，如果你熟悉Unity 3D的开发，就直接用Unity 3D的package，因为80%的Tango APP都是用Unity 3D开发的，当然最多的就是游戏啦！ 环境准备Android Studio 2.2 USB debuggingPhab 2 Pro开启Developer option中的USB debugging，没有Developer option，那你肯定是Android开发新手，在Settings-&gt;About phone下连续点击7次Builｄ number就可以召唤出Developer option了。 获取示例代码1git clone https://github.com/googlesamples/tango-examples-java.git 打开Java Cloud point example 直接 control + R 选择Phab 2 Pro 如果出现以下错误:12Error:Execution failed for task ':app:transformNative_libsWithStripDebugSymbolForDebug'.&gt; java.lang.NullPointerException (no error message) 只需要将compileSdkVersion和targetSdkVersion的版本号跟buildToolsVersion保持一致。 安装成功 在手机上可以看到Cloud point，实时的总点数和点的平均深度。 更多https://github.com/lvonasek/tango/利用C API对采集到的Point cloud进行处理，实现三维重建的APP。近似的扫描效果: Daydream开发再来重温下Daydream的目的，可以简单看到是Cardboard的升级版本，但却定义了一个可以满足用户体验的最低硬件标准并开发了一整套API来让开发者可以方便的开发出高质量体验的应用。同样的Daydream APP需要一个Daydream ready的手机来运行或可以运行Cardboard apps且大于Android 4.4(kitkat)的手机，这里同样使用Phab 2 Pro。使用Daydream主要用来完成以下开发任务: Lens distortion correction. Spatial audio. Head tracking. 3D calibration. Side-by-side rendering. Stereo geometry configuration. User input event handling. 获取代码1git clone https://github.com/googlevr/gvr-android-sdk.git Android Studio打开gvr-android-sdk 运行（ control + R）sample-sdk-treasurehunt 选择 Phab 2 Pro 在手机上配合Cardboard或Daydream Viewer(当然国内的各种盒子也是可以的，由于Daydream Viewer自由没有添加计算能力，只是在操作手柄上加了外置九轴惯性测量单元来辅助精确追踪) 总结使用ZenFone AR和Daydream Viewer，预计总价不会超过人民币5000元，就可以不用拖长长的连接线，也不用再专门配备一个高性能主机，在家里完全自由的沉浸在Google Street View， YouTube， Netflix， Hulu， HBO以及诸如 Fantastic Beasts ， Where to Find Them， Need for Speed和Gunjack 2这些VR游戏中，不是安静的坐着，而是360度的自由视角。完美VR的硬件和API已经准备好了，着手自己的开发计划吧！","tags":[{"name":"Andorid","slug":"Andorid","permalink":"https://yangbo.tech/tags/Andorid/"},{"name":"Tango","slug":"Tango","permalink":"https://yangbo.tech/tags/Tango/"},{"name":"Daydream","slug":"Daydream","permalink":"https://yangbo.tech/tags/Daydream/"},{"name":"VR","slug":"VR","permalink":"https://yangbo.tech/tags/VR/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangbo.tech/tags/Gradle/"},{"name":"Andorid Studio","slug":"Andorid-Studio","permalink":"https://yangbo.tech/tags/Andorid-Studio/"}]},{"title":"Android Things-物联网开发","date":"2016-12-24T00:50:09.000Z","path":"2016/12/24/android-things-for-iot-era/","text":"Android Things正式接替Brillo亮相，名称的改变带来了什么新的内容，广大Android开发者如何进入这一新的领域，通过本文，你不仅会了解Android Things的来龙去脉，也会直接通过代码来体验开发带给你的魅力。 Android Everywhere一张Google IO 2015上的旧图，清晰的展示了Android的历史和未来。 Android 处于中心的Android Mobile，已经占据了全球手机市场绝大多数份额，几十亿部Android手机，构成了Android生态系统最坚实的基础。 Android TV 随着着电视大屏发展的脚步，Android TV也成了所有电视盒子和智能电视的不二之选，主要归功于Android硬件系统的开放、庞大的开发者群体、完整的工具链。如果说手机端还有iOS将近20%的份额，在TV端，目测tvOS不到2%，Android TV也就代表了整个智能电视，国内更是100%的Android TV,Apple TV没有国行版本。 Android Wear 让你的应用跑在手表上，同样使用熟悉的开发工具，主要是面向海外的应用，由于国内Android Mobile严重分裂，而Android Wear需要依赖手机的支持。 Android Auto 针对汽车的使用场景进行优化，有了Android Auto就不用上车后就是找电源线，然后开导航，再把手机放到各种架子上，而是直接把Android Mobile放到原生底座上，直接使用语音和易操作的中控大屏。 Android Chromebook 从 Chrome 操作系统版本 M53 开始，可以直接使用Chromebook中的Google Play Store下载和使用Android应用，现在使用的Google Chrome版本是55，那么绝大多数已有Chromebook都已经支持Android应用，新的Chromebook自然都会支持。针对 Chromebook 优化应用支持Android应用的Chromebook列表Android和Chrome两大系统的合并，除了带来了Android丰富的应用以外，对于用户最大的好处就是自动更新了，Chrome自动下载更新，下次重新打开/启动时自动应用更新，从Android Nougat开始，Android系统也将使用这种更新机制。根据IDC报告,Chromebook在2016年第一季度的出货量已经在美国市场超越了Mac，特别是由于教育市场的大量需求。这里，还要注意,Chromebook使用的Chrome OS和Google Chrome高度共享代码，既然Android应用可以在Chromebook上运行，当未来在Mac/Windows/Linux上可以时，你也不要感到惊讶。 Android Things终于到了今天的主角登场，Android Things！先看外表。 再看内部核心硬件。 它的愿景就是将无数的的设备连接起来，Android Things作为物联网的大脑，使用公开协议Weave与广大的传感器/外部设备进行对话。不像Android其它系统，Android Things大多数情况下只在后台以服务方式运行，没有显示屏，默默的与打印机、门锁、烤箱、灯泡、插座这些设备一起提供服务。 Android Things全解析## Android Things架构 先看Brillo和Android Things的架构图进行对比。这是Brillo， 这是Android Things， 可以很清楚的看出来： Brillo使用C/C++基于NDK进行开发,Android Things通过Java API面向广大的Android和Java开发者，就算是新手，Android的也是极易上手的。各位苦于嵌入式开发各种工具坑的福音到了，对于性能和底层要求高的部分仍然可以用NDK编写，在Android Studio里调试NDK代码也和Java代码一样的简单。 Android Studio，Android SDK，Play service和Firebase,这些工具和Service形成了完整易用的工具链。 Android Things出生最晚，更新条件也是最好的，直接使用Android Nougat的自动后台更新机制，最大限度的提高系统的安全性。##广泛的硬件平台支持现在支持以下3款硬件Intel Edison开发版中的贵族。 NXP Pico中规中矩的中间阶层。 Raspberry Pi 3少了草根精英树莓派怎么行。 Hello Android Things买到的开发版都是没有装操作系统系统的，第一步先把Android Things刷到板子里。 Flash image(刷机)官方刷机教程以Intel Edison为例:0.Android SDK Platform Tools 25.0.3以上，fastboot工具添加到PATH环境变量中，以便从任意目录运行。1.下载后打Intel Flash Tool，加打开下载好的对应刷机包。 使用USB线链接Edison，如果Edison没有显示，换USB口和线试试。 Start to Flash（开始刷机） 4.使用Fastboot刷入系统镜像，此时需要几十秒，光System.img就有500多M。 5.刷入Google Service镜像。 6.刷入OEM镜像。 7.重启 1fastboot reboot 8.验证系统状态。 如果出现以下Error，把Intel Flash Tool关掉，重新连接下USB。12345678List of devices attachedadb server version (35) doesn't match this client (36); killing...adb E 69469 2714428 usb_osx.cpp:327] Could not open interface: e00002c5adb E 69469 2714428 usb_osx.cpp:289] Could not find device interfaceerror: could not install *smartsocket* listener: Address already in useADB server didn't ACK* failed to start daemon *error: cannot connect to daemon Connecting WIFI(联网)依然是熟悉的adb命令和服务启动参数12345$ adb shell am startservice \\ -n com.google.wifisetup/.WifiSetupService \\ -a WifiSetupService.Connect \\ -e ssid SSID \\ -e passphrase password 用logcat查看网络状态12345$ adb logcat -d | grep Wifi...V WifiWatcher: Network state changed to CONNECTEDV WifiWatcher: SSID changed: ...I WifiConfigurator: Successfully connected to ... Ping检测123456$ adb shell ping 114.114.114.114PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.64 bytes from 114.114.114.114: icmp_seq=1 ttl=57 time=6.67 ms64 bytes from 114.114.114.114: icmp_seq=2 ttl=57 time=55.5 ms64 bytes from 114.114.114.114: icmp_seq=3 ttl=57 time=23.0 ms64 bytes from 114.114.114.114: icmp_seq=4 ttl=57 time=245 ms Hello Android Things项目Android Studio中新建项目 在build.gralde中添加依赖com.google.android.things:androidthings12345678910111213141516171819202122232425262728293031apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.2\" defaultConfig &#123; applicationId \"com.geekdev.alpha.androidthings\" minSdkVersion 24 targetSdkVersion 25 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) provided 'com.google.android.things:androidthings:0.1-devpreview' compile 'com.google.android.things.contrib:driver-button:0.1' compile 'com.android.support:appcompat-v7:25.1.0' testCompile 'junit:junit:4.12'&#125; 此处依赖方式是provided，让Android Things使用系统中的库。 添加activity添加一个主activity并配置AndroidManifest.xml 1234567891011121314151617181920212223242526&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.geekdev.alpha.androidthings\"&gt;&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;uses-library android:name=\"com.google.android.things\"/&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.IOT_LAUNCHER\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; &lt;/manifest&gt; 在Activity中输出Hello Android Things123456789public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"Hello Android Things!\"); &#125;&#125; 运行输出直接Command+R，可以在logcat窗口中看到结果了。 Peripheral I/O不满足于Hello Android Things，继续来使用Android Things对外设进行操作。使用Button driver对LED灯进行开关操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.geekdev.alpha.androidthings;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.KeyEvent;import android.widget.Button;import com.google.android.things.contrib.driver.button.ButtonInputDriver;import com.google.android.things.pio.Gpio;import com.google.android.things.pio.PeripheralManagerService;import java.io.IOException;/** * Created by Alpha. * &lt;p&gt; * Example of using Button driver for toggling a LED. * &lt;p&gt; * This activity initialize an InputDriver to emit key events when the button GPIO pin state change * and flip the state of the LED GPIO pin. * &lt;p&gt; * You need to connect an LED and a push button switch to pins specified in &#123;@link BoardDefaults&#125; * according to the schematic provided above. */public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private Gpio mLedGpio; private ButtonInputDriver mButtonInputDriver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"Hello Android Things!\"); Log.i(TAG, \"Starting ButtonActivity\"); PeripheralManagerService pioService = new PeripheralManagerService(); try &#123; Log.i(TAG, \"Configuring GPIO pins\"); mLedGpio = pioService.openGpio(BoardDefaults.getGPIOForLED()); mLedGpio.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); Log.i(TAG, \"Registering button driver\"); // Initialize and register the InputDriver that will emit SPACE key events // on GPIO state changes. mButtonInputDriver = new ButtonInputDriver( BoardDefaults.getGPIOForButton(), Button.LogicState.PRESSED_WHEN_LOW, KeyEvent.KEYCODE_SPACE); mButtonInputDriver.register(); &#125; catch (IOException e) &#123; Log.e(TAG, \"Error configuring GPIO pins\", e); &#125; &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_SPACE) &#123; // Turn on the LED setLedValue(true); return true; &#125; return super.onKeyDown(keyCode, event); &#125; @Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_SPACE) &#123; // Turn off the LED setLedValue(false); return true; &#125; return super.onKeyUp(keyCode, event); &#125; /** * Update the value of the LED output. */ private void setLedValue(boolean value) &#123; try &#123; mLedGpio.setValue(value); &#125; catch (IOException e) &#123; Log.e(TAG, \"Error updating GPIO value\", e); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mButtonInputDriver != null) &#123; mButtonInputDriver.unregister(); try &#123; mButtonInputDriver.close(); &#125; catch (IOException e) &#123; Log.e(TAG, \"Error closing Button driver\", e); &#125; finally &#123; mButtonInputDriver = null; &#125; &#125; if (mLedGpio != null) &#123; try &#123; mLedGpio.close(); &#125; catch (IOException e) &#123; Log.e(TAG, \"Error closing LED GPIO\", e); &#125; finally &#123; mLedGpio = null; &#125; mLedGpio = null; &#125; &#125;&#125; 添加一个开发板的处理工具类BoardDefaults.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.geekdev.alpha.androidthings;import android.os.Build;import com.google.android.things.pio.PeripheralManagerService;import java.util.List;/** * Created by Alpha. */public class BoardDefaults &#123; private static final String DEVICE_EDISON_ARDUINO = \"edison_arduino\"; private static final String DEVICE_EDISON = \"edison\"; private static final String DEVICE_RPI3 = \"rpi3\"; private static final String DEVICE_NXP = \"imx6ul\"; private static String sBoardVariant = \"\"; /** * Return the GPIO pin that the LED is connected on. * For example, on Intel Edison Arduino breakout, pin \"IO13\" is connected to an onboard LED * that turns on when the GPIO pin is HIGH, and off when low. */ public static String getGPIOForLED() &#123; switch (getBoardVariant()) &#123; case DEVICE_EDISON_ARDUINO: return \"IO13\"; case DEVICE_EDISON: return \"GP45\"; case DEVICE_RPI3: return \"BCM6\"; case DEVICE_NXP: return \"GPIO4_IO21\"; default: throw new IllegalStateException(\"Unknown Build.DEVICE \" + Build.DEVICE); &#125; &#125; /** * Return the GPIO pin that the Button is connected on. */ public static String getGPIOForButton() &#123; switch (getBoardVariant()) &#123; case DEVICE_EDISON_ARDUINO: return \"IO12\"; case DEVICE_EDISON: return \"GP44\"; case DEVICE_RPI3: return \"BCM21\"; case DEVICE_NXP: return \"GPIO4_IO20\"; default: throw new IllegalStateException(\"Unknown Build.DEVICE \" + Build.DEVICE); &#125; &#125; private static String getBoardVariant() &#123; if (!sBoardVariant.isEmpty()) &#123; return sBoardVariant; &#125; sBoardVariant = Build.DEVICE; // For the edison check the pin prefix // to always return Edison Breakout pin name when applicable. if (sBoardVariant.equals(DEVICE_EDISON)) &#123; PeripheralManagerService pioService = new PeripheralManagerService(); List&lt;String&gt; gpioList = pioService.getGpioList(); if (gpioList.size() != 0) &#123; String pin = gpioList.get(0); if (pin.startsWith(\"IO\")) &#123; sBoardVariant = DEVICE_EDISON_ARDUINO; &#125; &#125; &#125; return sBoardVariant; &#125;&#125; 运行到如下的Raspberry Pi 3中，使用按钮来控制LED灯。 Code所有示例项目代码可有Github中找到. 更多到这里，你已经了解Android Things的历史，特点和开发。更多关于Google技术的内容，欢迎加入G tech online meetup微信群进行交流。","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"},{"name":"IOT","slug":"IOT","permalink":"https://yangbo.tech/tags/IOT/"}]},{"title":"利器系列-Web网络模拟工具，测试应用在低速不稳定网络中的表现","date":"2016-08-21T07:28:26.000Z","path":"2016/08/21/test-low-speed-load-for-web/","text":"在开发环境中，由于开发者对设备和网络通常是最高标准的要求，用以提高自己的生产效率，会产生灯下黑的情况，开发出的产品在稳定的高速网络下表现优异，这很重要，但要进行换位思考，还需要更上一层楼，Web产品的使用者越来越多的是移动网络，而移动网络的特点就是不稳定以及龟速的GPRS还有很多人在用，为了在开发和测试环境中做到用户环境的网络模拟，我们需要使用一系列工具来帮助我们开发测试更好的Web。 Chrome浏览器做为Web开发平台，Chrome提供了网络模拟，可以使用Chrome DevTools Network Panel内置或自定义的网络条件。 系统AndroidAndroid模拟器提供了网络设置 MacNetwork Link Conditioner，安装了Hardware IO Tools for XCode后，System Preference中会添加这个工具。 WinFiddler可以提供网速模拟，还可以搭配[GeoEdge] (http://www.geoedge.com/faq) 模拟异地网络访问。 网络Augmented Traffic Control使用Facebook的Augmented Traffic Control，使用启用了ATC网络的用户，都可以轻松选择控制自己的上网速度设置。 开发者只需要在浏览器页面上选择自己的网络配置，立即生效。这个工具要赞一个FB，FB还设立了2G Tuesdays项目，在周二的时候就弹出使用2G网络的提示，让开发者切身感受用户的使用体验。 自制ATC-enabled路由器设备：Netgear R7000，某东就有售步骤： 刷DD-WRT详细指南DD-WRT on R7000，下载刷机文件，使用Netgear Web Tool的Update Tool上传文件。使用路由器Web管理界面的用户名和密码SSH到路由器。刷机命令:1ddup --flash-latest 配置ATC存储开启USB存储把U盘格式化为ext3，此处先让U盘自动加载，不要填UUID到/opt，刷新页面后会出现UUID，填到/opt并保存。重新拔插U盘后刷新页面。 安装opkg包管理器123cd /tmp wget http://qnapware.zyxmon.org/binaries-armv7/installer/entware_install_arm.sh chmod +x entware_install_arm.sh ./entware_install_arm.sh 验证安装:1opkg update opkg安装成本，继续安装其它依赖。 安装其它依赖1opkg install ca-certificates python-base python-crypto python-logging nano easy_setup12curl https://bootstrap.pypa.io/ez_setup.py -k &gt; ez_setup.pypython ez_setup.py pip12curl https://bootstrap.pypa.io/get-pip.py -k &gt; get-pip.py python get-pip.py 安装ATC依赖1pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage 创建一个Django项目1234mkdir /opt/var/django cd /opt/var/django django-admin startproject atcui cd atcui 配置ACT编辑atcui/settings.py添加ATC到INSTALLED_APPS123456789101112INSTALLED_APPS = ( ... # Django ATC API 'rest_framework', 'atc_api', # Django ATC Demo UI 'bootstrap_themes', 'django_static_jquery', 'atc_demo_ui', # Django ATC Profile Storage 'atc_profile_storage',) 编辑atcui/urls.py将ACT路由添加以urlpatterns12345678from django.views.generic.base import RedirectView urlpatterns = patterns('', ... # Django ATC API url(r'^api/v1/', include('atc_api.urls')), # Django ATC Demo UI url(r'^atc_demo_ui/', include('atc_demo_ui.urls')), # Django ATC profile storage url(r'^api/v1/profiles/', include('atc_profile_storage.urls')), url(r'^$', RedirectView.as_view(url='/atc_demo_ui/', permanent=False)), ) django-bootstrap-themes patch:详见issue编辑/opt/lib/python2.7/site-packages/atc_demo_ui/templates/atc_demo_ui 更新Django DB1python manage.py migrate 启动ACT启动守护进程1sudo atcd 启动UI1python manage.py runserver 0.0.0.0:8000 测试http://192.168.18.1:8000,当然要换成你的路由器地址。 Bonus###全员参与设置一个nocatsplash到act的web ui,http://192.168.1.1:8000/atc_demo_ui/，用网的时候自动跳转的ACT配置界面。 ###ACTD开机自启在/opt/start下加一个startup.sh123#!/bin/sh atcd --atcd-wan vlan2 --atcd-lan br0 --atcd-mode unsecure --atcd-iptables /usr/sbin/iptables --daemon nohup python /opt/var/django/atcui/manage.py runserver 0.0.0.0:8000 &amp; 然后在DD-WRT的Web管理界面设置为startup script. SAASWebPageTest是一个在线服务，可以指定不同的浏览器版本和所在地，进行测试并提供详细的加载时间报表，用来优化页面访问。 WebPageTest还提供OpenAPI访问，用以把异地网络加载测试集成到整个构建测试流程中。 #小结现实世界遵循二八原理，为20%的用户开发的同时，也不要忘了还有更大的80%的用户君体，让你的Web产品提供最好的用户体验给最多的人，可以让这些工具来帮助我们。欲善其事，先利其器！","tags":[{"name":"Dev","slug":"Dev","permalink":"https://yangbo.tech/tags/Dev/"},{"name":"Web","slug":"Web","permalink":"https://yangbo.tech/tags/Web/"},{"name":"Test","slug":"Test","permalink":"https://yangbo.tech/tags/Test/"},{"name":"Tool","slug":"Tool","permalink":"https://yangbo.tech/tags/Tool/"}]},{"title":"1分钟搭建自定义域名的本地HTTPS开发服务器","date":"2016-08-19T09:32:30.000Z","path":"2016/08/19/local-https-server-with-custom-domain-in-1-minute/","text":"越来越多的Web API调用依赖HTTPS环境，比如Web Bluetooth API，Web Geo API,Web Notificaiton API等等，以下步骤快速搭建一个HTTPS开发服务器。 环境准备OS X 10.11.6（El Capitan)Python 2.7.10 (OS自带)OpenSSL 1.0.2h 3 May 2016(brew install openssl)Google Chrome Version 52.0.2743.116 (64-bit) 生成证书1openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes 证书信息都可以留空，只有Common Name填写自定义域名，此处使用通二级域名Common Name (e.g. server FQDN or YOUR name) []:*.alpha.me会在当前目录下生成server.pem证书。 使用证书vi https-server.py123456789import BaseHTTPServer, SimpleHTTPServerimport sslhttpd = BaseHTTPServer.HTTPServer(('localhost', 4443), SimpleHTTPServer.SimpleHTTPRequestHandler)httpd.socket = ssl.wrap_socket (httpd.socket, certfile='./server.pem', server_side=True)httpd.serve_forever() 启动https服务器1python simple-https-server.py Chrome访问https://localhost:4443 不受信的证书提醒 添加证书到可性查看证书信息 将证书样的图片拖到桌面，在桌面生成一个*.alpha.me.cer的文件，双击直接导入到Keychain Access 双击打开新添加的证书 设置为总是信任 关闭证书信息，需要输入用户密码 图标变成蓝十字，说明更改成功 添加域名到/etc/hosts1sudo vi /etc/hosts 结果重启Chrome，浏览器https://1.alpha.me:4443","tags":[{"name":"Dev","slug":"Dev","permalink":"https://yangbo.tech/tags/Dev/"},{"name":"OS X","slug":"OS-X","permalink":"https://yangbo.tech/tags/OS-X/"}]},{"title":"禁止Android File Transfer自动启动","date":"2016-08-16T11:18:08.000Z","path":"2016/08/16/disable-android-file-transfer-auto-start/","text":"Android File TransferAndroid File Transfer是Google官方提供的Android设备与Mac之间传统文件工具，默认情况下Android设备连接后就自动启动Android File Transfer，对于普通用户来讲，这是个方便之举，连接就是为了传文件，但开发者很多是为了调试应用，默认打开就成了画蛇添足。 Environment:Android File Transfer:1.0.0OS X EI Capitan 禁止步骤:Close Android File TransferOpen Activity Monitor and kill “Android File Transfer Agent”Go to where you installed “Android File Transfer.app” (I have it under /Applications)Ctrl+click –&gt; “Show package contents”Go to Contents/ResourcesRename “Android File Transfer Agent” to e.g. “Android File Transfer Agent_DISABLED”Then go to “/Users/username/Library/Application Support/Google/Android File Transfer” and again rename the Agent app.结果不会自动启动了，需要时直接Alfred","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"},{"name":"OSX","slug":"OSX","permalink":"https://yangbo.tech/tags/OSX/"}]},{"title":"Google IO 2016 地图开发技术回顾 - 一场地理数据开发创新博览会","date":"2016-05-31T11:30:35.000Z","path":"2016/05/31/io-16-geo-redux/","text":"会场Shoreline AmphitheaterGoogle IO 2016首次将会场从位于旧金山市区的Moscone Center West移师到了Google Campus一路之隔的露天大剧场，有了更大的会场，将以往2天的会期延长到了3天，都是满满的干货，技术控表示太开心了。 IO大巴实时地图如何从酒店到会场，Maps来帮你了解摆渡车安排 CODE THE ROAD到了地图博览会的核心地带，CODE THE ROAD大巴，从去年IO开始出发，足迹已经遍布了整个美国，今年再次从起点出发。 360度全景展示大巴内景原片地址(需梯子），使用鼠标或键盘控制全景方位https://www.youtube.com/watch?v=z8RR0BMYLco 技术控说：在Chrome中查看视频，是标准的HTML5 Video标签，使用全影录像设备生成的内容，都可以使用标准的Web技术来提供访问。 大巴外景全景图猛击访问 大巴车顶全景图猛击访问 制作全景图可以使用https://www.google.com/maps/streetview/publish/ 虚拟赛道After Hour的自行车比赛。可以选用Google街景的任意路线做为赛道，沉浸式的骑行体验，让健身乐趣无穷。 Terra Bella satellite imageryhttps://terrabella.google.com收购的Skymap，改名为Terra Bella，使得大众化的卫星实时数据查看和开发在不久的将来得以实现。 Google Maps API beta program地图开发者参加Beta计划，得到最优先使用前沿开发资料。点击加入Beta Program 地图开发演讲Streamlining developer experiences with the Google Maps APIs最新的Google地图开发汇总Youtube Video Understand your Place in this world如何使用全球最全的的POI数据来开发你的超酷应用Youtube VideoCode Lab Location and Proximity Superpowers: Eddystone + Google Beacon Platform使用Eddystone和Google Beacon Platform开发基于位置和周边的服务Youtube Video Building Geo services that scale搭配Google Cloud Platform和Google Maps API开发安全和可扩展的位置服务Session reCAPTCHA: Tough on Bots, Easy on Humans, Great on Mobile利用位置信息提高验证系统的用户体验Youtube Video 无人驾驶汽车地图，导航，大数据，云计算，人工智能……，一辆无人驾驶汽车，就是将位置数据开发利用的集大成者，让多少人魂牵梦萦，利用这次大场地的活动，Google将自家的原型车搬到了会场，让与会开发者一饱眼福。 气球计划气球互联网计划也是首次在IO大会上露出真容，希望这种普惠式的网络访问方式能够早一天在地球实现！","tags":[{"name":"Maps API","slug":"Maps-API","permalink":"https://yangbo.tech/tags/Maps-API/"},{"name":"Cloud","slug":"Cloud","permalink":"https://yangbo.tech/tags/Cloud/"},{"name":"Big Data","slug":"Big-Data","permalink":"https://yangbo.tech/tags/Big-Data/"},{"name":"AI","slug":"AI","permalink":"https://yangbo.tech/tags/AI/"}]},{"title":"client-security-from-google","date":"2016-05-29T09:32:30.000Z","path":"2016/05/29/client-security-from-google/","text":"引子XcodeGhostStagefrighthttp://www.theguardian.com/technology/2015/jul/28/stagefright-android-vulnerability-heartbleed-mobilehttp://www.androidcentral.com/stagefrighthttp://www.digitaltrends.com/mobile/android-stagefright-mms-hack-news/在彩信中插入恶意小视频，系统会自动在用户看到前触发Stagefright，中招。利用Android 5.1.1, build LMY48I系统更新。 开发者开发人员坚持从官方更新开发工具， 保持干净的系统，安全意识很重要团队提供稳定的网络环境，不只有利于团队人员的技术成长，更是打造竞争力产品的需要。老话：安全，至关重要。 用户设备购买购买设备时，不只比拼硬件的参数，系统的持续更新能力不止体现在更多的功能，也表示更好的系统安全保证。 iOS系统更新是包含在购买价格中的，全球所有用户都可以处于同一安全水平。 Android选购Android比较复杂： Google的Nexus首选，纯净系统与最新最快的系统更新，不只需要硬件海淘，还要有稳定的科学上网能力； 次选MIUI，拥有系统的持续更新能力； 只使用Google Play市场，Google最有动力也最有实力保证市场中应用的安全性； 不Root，即使刷机后要把BootLoader重新锁上；远程锁定和数据抹除Android和iOS都支持找回手机功能，利用原理一样，设备检测到网络即报告自己的位置信息，已经有不少新闻报道提到通过这种方式找回了丢失的手机。同样的原理，移动设备在丢失后可以远程抹除数据 密码策略开启2步验证主力帐户，如 Google Account, Apple ID，支付宝，微信，LastPass等开启两步验证。即使密码泄漏，还需要手机验证码才能访问帐户。 2 step verificationapple id的保护：apple id, recovery key， password有两项才可解锁帐户，使用密码登陆时使用绑定手机或设备接收4位验证码。 密码管理软件推荐 LastPass，推荐链接类似于自家保险柜和银行保险柜的差别，不只是只记一个密码了，密码信息保护能力有了质的提升。 一个服务一个密码登陆帐户无所不在，配合 LastPass 实施一个帐户一个密码，也不排队有异常能力的人可以通过一定的规则来人工实现这一增强机制。 浏览器Chrome简单就是最好，使用Google Chrome帐户同步，基于 Chrome 的安全快速特性，不只保持浏览器网页时的安全，也将浏览数据保护起来，如果设备丢失，检测是否能远程删除同步数据 更多恶意网页检测API浏览器开发者可以利用 Google 的恶意网页检测API来增强用户浏览的安全性，让你的浏览器可以拥有和 Chrome 一样的安全网页检测功能。 Andorid 和 Chrome 的漏洞报告奖励Android Rewardshttps://www.google.com.sg/about/appsecurity/android-rewards/ Chrome Rewardshttps://www.google.com.sg/about/appsecurity/chrome-rewards/ 案例应用泄露用户信息，因为应用加密做的很差，公开后才引起重视https://www.larrysalibra.com/how-chinese-tinder-clone-screws-you/https://www.larrysalibra.com/tantan-responds-promises-encryption/","tags":[]},{"title":"Android Studio 2.0","date":"2015-11-28T11:45:34.000Z","path":"2015/11/28/android-studio-20/","text":"Android Studio 1.5刚推出几天，2.0就正式在 Canary 通道中放了出来，从1到2是一个大的版本升级，最主要就是体现在“快”这一个字上，也就是提速 app 的 build 和 deployment。 获取2.0全新安装下载 修改 update channel‘Command+,’ Tips：Canary，Dev，Beta，Stable 四个 Channel 从 Chrome 项目中借鉴过来，也几乎变成了 Google 发布客户端更新的官方范式 Canary：weekly build(chrome 中 Canary 为 daily build) 发布依次由 Canary-&gt; Dev-&gt; Beta-&gt; Stable 不断推进，让 Bug 尽早发现并修复 改进dx dx工具负责将所有经过 javac编译生成的.class文件转换并合并成一个.dex（dalivk executable）文件 优化的 dx merger Build Tools 23.0.2+. 后台运行 dx(Run dx in process)，把 dx 工作分散到平时默默进行，不用挤到 build 时，降低 build 时间峰值 Gradle 2.4+ Plugin 2.0.0+ Build Tools 23.0.2+ 在 build.gradle 中启用12345android &#123; dexOptions &#123; dexInProcess = true &#125;&#125; 配置 gradle 最大 jvm 内存使用,dex.jar 运行在 gradle 内存空间中，gradle以 daemon 进程一直存活代替之前的按需启动的短生命周期实例。在 project 下的 gradle.properties 中设置 org.gradle.jvmargs=-Xmx4096m， 并行 dexer 最多可并行4个 dexer 任务 在 project 下的 gradle.properties 中使用android.dexerPoolSize环境变量来指定并行数量 ProGuard 不足： 不支持增量模式，每次都是全部处理一遍 阻止 pre-dexing，只支持单个 dex 输出且每次执行都是全部 re-dexing 改进： 部分增量模式支持 可以 pre-dexing 使用，不需额外配置，得到的好处就是快了123456789101112android &#123; buildTypes &#123; debug &#123; minifyEnabled true useProguard false &#125; release &#123; minifyEnabled true useProguard true &#125; &#125;&#125; multi-dex根据 connected Device API level: =21，即 art 上，运行时原生支持加载多个 dex 文件，在安装编译时将多个 dex 编译合在一起，","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"}]},{"title":"Android开发，不可不知的so文件知识大全","date":"2015-11-27T12:30:35.000Z","path":"2015/11/27/so-files-guide/","text":"引论如果你是做Android系统开发，对于so文件应该不会默认；如果是做应用开发，可能更了解jar或aar文件，但你也会不经意的在开发中或是要用到的第三库/SDK中看到so的身影，那你应该往下看，全面了解Android应用在运行时的另一个重要文件类型so。 什么是so文件so是shared object的缩写，见名思义就是共享的对象，机器可以直接运行的二进制代码。大到操作系统，小到一个专用软件，都离不开so。参见https://en.wikipedia.org/wiki/Library_(computing)so主要存在于Unix和Linux系统中。 .so vs .a.a:archive存档的含义，是unix系统中对于静态库的文件后缀，在软件打包时和主程序表态链接在一起，表现形式是在链接成同一个文件。go lang即广泛采用这一形式，对于软件分发只有一个文件。对于打包好的软件来讲，这是专属库，所有都在出厂前打包在一起了，好处是不受外界影响，坏处是任何改动要全部分发。对于安装应用的系统来讲，当然是共享的越多越好，既省内存又省硬盘。 .so:shared object共享库，用过Windows的同学应该都或多或少碰到过找不到DLL或DLL错误之类的问题，其中最为著名的问题就是DLL Hell（某个著名的库，软件a使用1.0，新装的软件b使用1.0.1，导致软件a运行异常），DLL即Dynamic Link Library的缩写，和shared object表示同样的事物，只是名字不同而已。运行时按需加载，不论是系统提供的共享库还是自带的共享库，最大化利用软件分治的原理，修Bug也是更新所在so文件，不需全部更新。 Android中的soso是与平台相关的二进制机器码，与ABI（Application Binary Interface）相对应，一个ABI表示相应的CPU的指令集与内存页管理，也对应于不同的C运行环境，所以so是有不同的系统版本的。随着Android系统的快速发展，搭载Android的硬件平台也早已多样化了（对比WinTel联盟，直到2012年才新发展了Windows RT来适配ARM平台，2015年的Win10才进入 Raspberry Pi 2这类基于ARM的新型设备中），现在已经运行在7个ABI：armeabi，armeabi-v7a (armeabi-v7a-hard)，arm64-v8a，x86，x86_64，mips 和 mips64。 为什么使用上面主要从软件开发的角度说明了为什么设计so以及开发者为什么使用so，由于Android基于Linux Kernl的，也继承了Linux中所有so相关的设计。除了系统方面的原因，Android开发者还要知道以下几点： so机制让开发者最大化利用已有的C和C++代码，达到重用的效果，利用软件世界积累了几十年的优秀代码 so是二进制，没有解释编译的开消，用so实现的功能比纯java实现的功能要快 so内存分配不受Dalivik/ART的单个应用限制，减少OOM基于以上的各种好处，so在Android开发中大量使用，利用Native Lib Monitor可以看到：微信（将近30个）： Google Drive： Youtube: PS1：从Youtube中的so文件可以看出安装后的应用混合使用arm和arm64两种ABI，体现了硬件的兼容性。ARM64和X86可以运行ARMv7，X86对ARMv7采用软件兼容，在CPU层面多一个指令集翻译环节，所以如果你是so文件的提供者，就算是增加工作量，也最好提供覆盖全渐ABI，让最终APP的性能不因为你而打折，这一点非常重要；作为应用开发者，在有选择的情况下，尽量选用覆盖全部ABI的库，体现为背后的技术实力。PS2：一个APK包中可以包含多个ABI的Library，而Android在安装APK时，会选择与自己最匹配的ABI安装到应用中。PS3：由PS1引发的一个问题：深爱广大Android开发者喜欢的Genymotion模拟器是基于virtualbox的x86架构，如果使用了不含x86 ABI的so库，就不能安装到Genymtion中。另外，如果Genymotion没有提供Play Service，如果开发需要的话，要安装Googel Apps x86。可以到根据你的模拟器系统版本下载合适的安装包，直接把下载好的zip包拖到Genymtion模拟器中，赚慢的话，也可以直接从我的百度网盘下载。 如何使用 Android Studio，将得到的ABI放到jniLibs/ABI12345678910├── AndroidManifest.xml└── jniLibs ├── armeabi │ └── libsnappydb-native.so ├── armeabi-v7a │ └── libsnappydb-native.so ├── mips │ └── libsnappydb-native.so └── x86 └── libsnappydb-native.so 或者使用jniLibs.srcDir属性指定：12345678android &#123; sourceSets &#123; main &#123; jni.srcDirs = [] //disable automatic ndk-build call jniLibs.srcDir 'main/libs' &#125; &#125;&#125; eclipse中直接放到libs/ABI目录。 在aar文件中，so处于jni/ABI目录中，对于库开发者和应用开发者都不必关注，全部自动处理。 在生成的APK中，所有so文件对应于lib/ABI中。 当APK安装到Android系统中时，so文件位置:Android&lt;5.0，/data/data/PACKAGE_NAME/libAndroid&gt;=5.0，/data/app/PACKAGE_NAME/lib/CPU_ARCH/和/data/data/PACKAGE_NAME/lib 可能会出现的问题使用了so本地库后，开发者可能会遇到“UnsatisfiedLinkError”，“dlopen: failed”等等能看见的问题，还会引发应用崩溃或性能低下等更隐蔽的问题。 避免问题的途径主要针对so文件的提供者： 请尽量覆盖全部ABI Android NDK向前但不向后兼容，可以适当忽略“compile against the latest platform”这类优化提示。简单说，利用NDK针对android-17生成的so文件可以在android-22上运行，反之却不行。这点与Android SDK的兼容性不一样，在SDK14上编译的应用，在API23上也是可以运行的；在SDk23上的编译的应用，只要minSdkVersion小于14，同样在API14上可以运行。. 对于采用so的应用开发者尽量保证你所使用的so文件编译编译的一致性，要了解你使用的库，在选择新库时要全面考虑。 针对Google Play进行分ABI上传上文中提到尽量使用覆盖全部ABI的库，其直接结果是让APK变大了好多，显然增加上用户下载负担，因为最终只会用到一个ABI，而下载的其它ABI就白白浪费了。我们来看Google的明星产品Maps是如何做的。 用户下载的安装包大小是不固定的，也就是根据用户设备的ABI自动选择相应的安装包。这是Google Play开发者和用户提供的一大功能。做为开发者，可以很方便的生成ABI对应的APK，只需在Module/build.gralde中添加：12345678910111213141516171819202122232425android&#123; ... splits &#123; abi &#123; enable true reset() include 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a' //select ABIs to build APKs for //universalApk true //generate an additional APK that contains all the ABIs &#125; &#125; // map for the version code project.ext.versionCodes = ['armeabi': 1, 'armeabi-v7a': 2, 'arm64-v8a': 3, 'mips': 5, 'mips64': 6, 'x86': 8, 'x86_64': 9] android.applicationVariants.all &#123; variant -&gt; // assign different version code for each output variant.outputs.each &#123; output -&gt; output.versionCodeOverride = project.ext.versionCodes.get(output.getFilter( com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode &#125; &#125;&#125; 生成的APKs： 上传Google Play Developer Console时使用Advnaced Mode： 总结Android开发给我们开发者提供了so这样一种机制，掌握它，利用它，让你的开发工作变得更轻松，让你写出的应用运行更流畅。 引用http://stackoverflow.com/questions/9688200/difference-between-shared-objects-so-static-libraries-a-and-dlls-sohttp://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.htmlhttp://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.htmlhttps://developer.android.com/ndk/guides/abis.htmlhttps://software.intel.com/en-us/blogs/2012/11/12/how-to-publish-your-apps-on-google-play-for-x86-based-android-devices-usinghttp://stackoverflow.com/questions/31666412/how-to-order-multiple-apks-with-native-libraries-in-google-play-storehttp://tools.android.com/tech-docs/new-build-system/user-guide/apk-splitshttps://androidbycode.wordpress.com/2015/07/07/android-ndk-a-guide-to-deploying-apps-with-native-libraries/","tags":[{"name":"Andorid","slug":"Andorid","permalink":"https://yangbo.tech/tags/Andorid/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangbo.tech/tags/Gradle/"},{"name":"Andorid Studio","slug":"Andorid-Studio","permalink":"https://yangbo.tech/tags/Andorid-Studio/"}]},{"title":"Hack Andorid，使设备变身专用信息显示屏","date":"2015-11-25T11:30:35.000Z","path":"2015/11/25/hack-android-for-display-only/","text":"引论机场、车站、高速服务区随处可见信息显示屏，有的高悬只做单向显示，有的在地面只可在屏幕上进行操作如导航、查询等，在Andorid之前这块是嵌入式以及Win Embed的领域。现在Android设备的成本以及性能，Andorid App开发技术和开发人员的丰富，用Android驱动信息展示机已是更为合理的趋势。 在这类设备上，绝大多数都是使用物理遮盖或硬件定制，将正常的Andorid系统所必需的控制按键进行了处理，使用过程中普通用户接触不到控制键，达到专用（不可退出，只能使用既定功能）的上的。 我们现在就来看看如何把一个正常的Android设备，通过软件Hack的方式，打造成这类的专用设备。 PS:Google官方的Cardboard应用即属此类，交互方式只剩下一个按垫片了。 分析Andorid系统本身是为移动设备开发的，包括UI和硬件交互设施： 返回键 Home键 应用切换键 音量键 电源键 除了屏蔽按键，应用需要系统启动后自动启动。UI根据需要按照App正常开发方法进行裁剪。 还需要注意的点： 健全的退出机制（任何情况下都要有的设计，类似后门） 普通用户必须知道如何退出，特别是通过应用商店分发（定制化场景不考虑退出） 软件方式只能覆盖一些应用场景，效果也不是最好，软硬结合才是王道。 Happy Hack##准备添加MyApplication全局入口12345678&lt;application android:name=\"com.geekdev.alpha.hack4andriodbuttons.MyApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt;&lt;/application&gt; 添加一个MainActivity123456789&lt;activity android:name=\"com.geekdev.alpha.hack4andriodbuttons.MainActivity\" android:label=\"@string/app_name\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 利用SharedPreference添加一个开关,Preference.java:1234567891011121314public class PreferenceUtils &#123; private static final String PREF_NoButtons_MODE = \"pref_NoButtons_mode\"; public static boolean isNoButtonsModeActive(final Context context) &#123; SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context); return sp.getBoolean(PREF_NoButtons_MODE, false); &#125; public static void setNoButtonsModeActive(final boolean active, final Context context) &#123; SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context); sp.edit().putBoolean(PREF_NoButtons_MODE, active).commit(); &#125;&#125; 自启动在Android.manifest中添加权限和Receiver：1&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" /&gt; 添加启动广播Receiver：12345&lt;receiver android:name=\"com.geekdev.alpha.hack4andriodbuttons.BootReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; BootReceiver.java: 123456789 public class BootReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Intent myIntent = new Intent(context, MainActivity.class); myIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(myIntent); &#125;&#125; 返回键重写MainActivity中的onBackPressed方法：12345@Override public void onBackPressed() &#123; Log.i(TAG,\"can't back\"); &#125; Home键重头戏，由于Android不允许改变Home键的行为，所以只能做一些Workaround来绕过限制。起一个Service，作为守护Service，死循环，每隔3s检查应用是否在前台运行，没有运行则唤醒。由于Android设置了Home键放开后延迟5s才执行Service起动Activity的逻辑，小于5s的轮询都可以，为了绕过这个5s限制，ROOT后的系统把应用移动到/system/app且取”android.permission.STOP_APP_SWITCHES”权限。当然如果硬件上把Home键做处理，就自然不会有这个5s延迟了。在AndroidManifest中声明Service：123&lt;service android:name=\"com.geekdev.alpha.hack4andriodbuttons.NoButtonsService\" android:exported=\"false\" /&gt; 在MyApplication应用启动时启动NoButtonsService：12345678910111213public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); instance = this; startNoButtonsService(); &#125; private void startNoButtonsService() &#123; startService(new Intent(this, NoButtonsService.class)); &#125;&#125; 在NoButtonsService中实现守护逻辑:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class NoButtonsService extends Service &#123; private static final long INTERVAL = TimeUnit.SECONDS.toMillis(3); // 3s 轮询 // Home button pressed, user app service has 5s delay in order to make sure user has full choice //if the system is rooted, move user app to system app, 5s delay removed private static final String TAG = NoButtonsService.class.getSimpleName(); private Thread t = null; private Context ctx = null; private boolean running = false; @Override public void onDestroy() &#123; Log.i(TAG, \"Stopping service 'NoButtonsService'\"); running =false; super.onDestroy(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(TAG, \"Starting service 'NoButtonsService'\"); running = true; ctx = this; // start a thread that periodically checks if your app is in the foreground t = new Thread(new Runnable() &#123; @Override public void run() &#123; do &#123; handleNoButtonsMode(); try &#123; Thread.sleep(INTERVAL); &#125; catch (InterruptedException e) &#123; Log.i(TAG, \"Thread interrupted: 'NoButtonsService'\"); &#125; &#125;while(running); stopSelf(); &#125; &#125;); t.start(); return Service.START_NOT_STICKY; &#125; private void handleNoButtonsMode() &#123; // is NoButtons Mode active? if(PreferenceUtils.isNoButtonsModeActive(ctx)) &#123; // is App in background? if(isInBackground()) &#123; restoreApp(); // restore! &#125; &#125; &#125; private boolean isInBackground() &#123; ActivityManager am = (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; taskInfo = am.getRunningTasks(1); ComponentName componentInfo = taskInfo.get(0).topActivity; return (!ctx.getApplicationContext().getPackageName().equals(componentInfo.getPackageName())); &#125; private void restoreApp() &#123; // Restart activity Intent i = new Intent(ctx, MainActivity.class); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ctx.startActivity(i); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 应用切换键在MainActivity中重写onPause方法，直接用ActivityManager把MainActivity放在最前：123456789@Override protected void onPause() &#123; super.onPause(); ActivityManager activityManager = (ActivityManager) getApplicationContext() .getSystemService(Context.ACTIVITY_SERVICE); activityManager.moveTaskToFront(getTaskId(), 0); &#125; 别忘了添加权限：1&lt;uses-permission android:name=\"android.permission.REORDER_TASKS\" /&gt; 音量键在MainActivity中定义音量键并重写dispatchKeyEvent:1234567891011private final List blockedKeys = new ArrayList(Arrays.asList(KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_UP));@Overridepublic boolean dispatchKeyEvent(KeyEvent event) &#123; if (blockedKeys.contains(event.getKeyCode())) &#123; //检测到音量键直接return return true; &#125; else &#123; return super.dispatchKeyEvent(event); &#125;&#125; 电源键短按短按是为了关闭屏幕，监听OnScreenOff的系统广播，在应用启动时注册。OnScreenOffRecever：12345678910111213141516171819202122232425262728public class OnScreenOffReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(Intent.ACTION_SCREEN_OFF.equals(intent.getAction()))&#123; MyApplication ctx = (MyApplication) context.getApplicationContext(); // is NoButtons Mode active? if(PreferenceUtils.isNoButtonsModeActive(ctx)) &#123; wakeUpDevice(ctx); &#125; &#125; &#125; private void wakeUpDevice(MyApplication context) &#123; PowerManager.WakeLock wakeLock = context.getWakeLock(); // get WakeLock reference via MyApplication if (wakeLock.isHeld()) &#123; wakeLock.release(); // release old wake lock &#125; // create a new wake lock... wakeLock.acquire(); // ... and release again wakeLock.release(); &#125;&#125; 应用启动时注册:123456789101112131415161718192021222324252627282930313233343536public class MyApplication extends Application &#123; private MyApplication instance; private PowerManager.WakeLock wakeLock; private OnScreenOffReceiver onScreenOffReceiver; @Override public void onCreate() &#123; super.onCreate(); instance = this; registerNoButtonsModeScreenOffReceiver(); startNoButtonsService(); &#125; private void registerNoButtonsModeScreenOffReceiver() &#123; // register screen off receiver final IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF); onScreenOffReceiver = new OnScreenOffReceiver(); registerReceiver(onScreenOffReceiver, filter); &#125; public PowerManager.WakeLock getWakeLock() &#123; if(wakeLock == null) &#123; // lazy loading: first call, create wakeLock via PowerManager. PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); wakeLock = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP, \"wakeup\"); &#125; return wakeLock; &#125; private void startNoButtonsService() &#123; startService(new Intent(this, NoButtonsService.class)); &#125;&#125; 别忘了添加WAKE_LOCK权限：1&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; 长按长按是为了关机，直接把系统的关机弹出对话框处理掉，这里只要系统对话框都关掉。在MainActivity中重写onWindowFocusChanged焦点变化时：12345678910@Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if(!hasFocus) &#123; // Close every kind of system dialog Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); sendBroadcast(closeDialog); &#125; &#125; 防止屏幕自动关闭屏幕在Layout文件中添加为根视图添加属性:1android:keepScreenOn=\"true\" 在MainActivity的onCreate方法中添加，要放在setContentView之前:12getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD); 开关开启放在MainActivity的onResume而不是onCreate，避免开关关闭后，离开应用而应用没有被系统回收，再次打开应用时onCreate没有开启开关。12345@Override protected void onResume() &#123; super.onResume(); PreferenceUtils.setNoButtonsModeActive(true, getApplicationContext()); &#125; 关闭设置一个Button监听事件：12345678910Button fab = (Button) findViewById(R.id.hiddenExitButton); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; PreferenceUtils.setNoButtonsModeActive(false, getApplicationContext()); Snackbar.make(view, \"可以退出了\", Snackbar.LENGTH_SHORT) .setAction(\"Action\", null).show(); &#125; &#125;); 结论我们通过以上Hack步骤，将一个Android设备变成了专用机，可以看到Android以其独特的开放特性可以覆盖足够多的使用场景，也符合Google提出的Android is everywhere的口号。 项目地址：github Referencehttp://developer.android.com/intl/zh-cn/reference/android/view/WindowManager.LayoutParams.html#FLAG_DISMISS_KEYGUARDhttp://developer.android.com/intl/zh-cn/training/scheduling/wakelock.html","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"}]},{"title":"利用 Street View API 制作街景小动画","date":"2015-11-15T11:30:35.000Z","path":"2015/11/15/gif-movie-by-street-view-api/","text":"效果Google街景小车开启了地图与现实结合的大门，也让我们可以利用 Google Maps 浏览全世界的美丽风光。街景车采集的数据简单来说就是加了经纬度的图片，我们也可以利用这些图片来制作街景小动画，上香港示例（大陆没有Google 街景数据）： Coding使用 Direction API 进行两地间导航，利用 Street View API 将街景图片预加载，使用了 Hyperlaps.js，Hyperlapse.js依赖 GSVPano 和 three 两个 js 库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Simple Example&lt;/title&gt; &lt;script src=\"https://maps.googleapis.com/maps/api/js?v=3.exp\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/GSVPano.js\"&gt;&lt;/script&gt; &lt;script src=\"js/Hyperlapse.js\"&gt;&lt;/script&gt; &lt;script&gt; function init() &#123; var hyperlapse = new Hyperlapse(document.getElementById('pano'), &#123; lookat: new google.maps.LatLng(37.81409525128964,-122.4775045005249), zoom: 1, use_lookat: true, elevation: 50 &#125;); hyperlapse.onError = function(e) &#123; console.log(e); &#125;; hyperlapse.onRouteComplete = function(e) &#123; hyperlapse.load(); &#125;; hyperlapse.onLoadComplete = function(e) &#123; hyperlapse.play(); &#125;; // Google Maps API stuff here... var directions_service = new google.maps.DirectionsService(); //设置起始点，进行导航 var route = &#123; request:&#123; origin: new google.maps.LatLng(22.2962259,114.1724561), destination: new google.maps.LatLng(22.3025739,114.1720511), travelMode: google.maps.DirectionsTravelMode.DRIVING &#125; &#125;; directions_service.route(route.request, function(response, status) &#123; if (status == google.maps.DirectionsStatus.OK) &#123; hyperlapse.generate( &#123;route:response&#125; ); &#125; else &#123; console.log(status); &#125; &#125;); &#125; window.onload = init; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"pano\"&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; Git 仓库https://github.com/alphayang/hongkong_fast_street_view 更多新车试驾，旅游规则，展览。。。 Tips加载 maps api 需科学上网，加载图片时间视需下载街景图片数据而不同，由于是全部下载完成再开始播放，需要些耐心。由于国内 google maps api 还没有街景资源，此处不能用使用国内http://www.google.cn/maps/api/js","tags":[{"name":"Google Maps api","slug":"Google-Maps-api","permalink":"https://yangbo.tech/tags/Google-Maps-api/"}]},{"title":"向Google学习，打造安全的服务","date":"2015-11-14T02:39:21.000Z","path":"2015/11/14/service-side-security-from-google/","text":"引子网易邮箱过亿数据泄漏（涉及邮箱账号/密码/用户密保等）http://www.wooyun.org/bugs/wooyun-2015-0147763如果重大的安全事件，发生在曾经的三大门户之一并且是唯一以工程师起家的服务上，实在是让人心寒。互联网已经是现代生活的基础，基础设施的安全关系到我们每一个人，开发者，普通使用者。开发者对安全应该有更高的要求，更高的追求。 携程携程的安全事件2015年5月28日11时许，携程网官网出现大面积瘫痪，网页版和手机APP均不能正常使用。携程方面对此回应称服务器遭到不明攻击。5月28日22:45，携程官方回应称，经技术人员抢修，除个别业务外，携程官方网站及APP恢复正常，经过排查，携程郑重声明，数据没有丢失，预订数据也保存完整。 Google 的安全榜样的力量是无穷的，对于安全，处于互联网最前沿的Google面临着更复杂更险峻的挑战，迄今为止，Google还没有发生严重的安全事件，那么从技术从业者的角度来向行业标杆看齐，让用户信息更安全。 硬件自建机房由于极快速的成长，IDC及托管很快不能满足Google的需要，开始自建机房。对于机房建设，Google相对比较开放，机房位置，内部运作流程以及使用到的技术都有公开。https://www.google.com/about/datacenters/gallery/#/http://www.google.com/about/datacenters/inside/streetview/ 机房涉及到的安全威胁就是人为的入侵，提高安保水平，更主要是让入侵白忙活，从软件系统设计上进行加密。 高标准入侵演习外星人入侵http://thenextweb.com/google/2011/08/23/alien-attacks-california-destruction-just-part-of-googles-disaster-recovery-plan/ 自造服务器很多开发者都有过攒机的经历，这也是体现“技术”的地方，硬件定制化，以最经济的成本满足特定的需求。那么Google作为技术性创业的典范，从诞生起就对它的硬件环境进行了定制。从市场上采购性价比最高的廉价PC配件，自行组装。下图是收藏于San Francisco Computer History Museum的最早的Google机柜，曾经仔细观察过内部，1999年左右使用4G的硬盘，回想当时动辄过万的联想家用PC也只有256M的硬盘，在美帝和硅谷占尽先机，相同条件下硬件设备的价格以及相应人才优势。 零星的公开了一些信息：http://www.cnet.com/news/google-uncloaks-once-secret-server-10209580/在WikiPekia上有一些Google server的硬件概况：https://en.wikipedia.org/wiki/Google_platform 在Google Compute Engine的类型说明中，可以看到CPU和总线的影子：https://cloud.google.com/compute/docs/machine-types Google Search Appliance值得一提的是Google的这一款企业级搜索一体机产品，将机箱放到自己的网络环境里，就可以工作，用来索引内部或外部资源。先爆照： 根据Google和Dell的官方描述，服务器是由Dell OEM的。可以看来，Google负责根据需要设计和提需求，找硬件厂商OEM是现在Google Server最可能的一种生产形式。https://support.google.com/gsa/answer/6055109?hl=enhttp://www.dell.com/downloads/global/power/2009-google-10008089.pdf 有兴趣的同学还可以到eBay上买到这类机器http://www.ebay.com/bhp/google-server PS：Google从来没有公开披露过自己的服务器数量，小道消息是：超过500万台，全球排在Top 5服务器制造商中。PS：经常听说一些大厂为了数据安全，将所有USB口用胶水封死，也算是做到了制定计算设备的目的。 系统使用自己裁剪的Linux版本，从软件栈的底层开始控制安全风险。https://www.quora.com/What-operating-system-do-Google-use-for-their-servershttps://github.com/googlegsa/mirror.72/tree/master/rpm 存储所有的数据最终都存储在硬盘上，跟踪每一块硬盘的位置和状态，对于坏损硬盘执行销毁流程。https://www.google.com/about/datacenters/inside/data-security/销毁方式：https://www.youtube.com/watch?v=wNyFhZTSnPgGoogle Cloud Storage，进行AES-256加密，由用户提供key。https://cloud.google.com/compute/docs/disks/customer-supplied-encryptionhttp://www.theverge.com/2013/8/16/4627232/google-cloud-storage-automated-128-bit-aes-security对Google Drive中的文件，也进行了加密。https://www.boxcryptor.com/en/google-drive多区域分布式存储和备份，保证全球的数据访问。PS：对于个人用户，Gmail的存储并没有说明是否加密。 组织持续投入400+全职安全工程师，养了不少安全大牛。拿钱砸，直接买公司。http://tech.firstpost.com/news-analysis/google-picks-indian-connect-startup-imperium-216605.htmlhttp://www.computerworld.com/article/2472903/cloud-computing/why-google-bought-virustotal.html 工程能力 员工审计和最小权限一切的访问活动都以最小权限开发，有完整的访问记录提供审计能力。 Vulnerability Rewards Program鼓励Hack，奖励发现漏洞的白帽子。简单对比了下，是所有国际性大厂里提供漏洞奖励最高的。已提供超过200万美刀的奖励。https://www.google.com/about/appsecurity/reward-program/ 第三方认证安全不能是自说自话，必须要有客观公正独立的第三方审计来保证安全措施的有效。安全工程师保证数据的安全，再加上律师的努力，让安全流程符合规则，获得第三方机构的认证。 PCI DSSPayment Card Industry Data Security Standard，对支付数据的传输、处理和保存进行了严格的规定。 HIPAAHealth Insurance Portability and Accountability，个人健康信息的隐私保护标准。 ISO 27001信息安全管理,是国际上具有代表性的信息安全管理体系标准，Google获取的是最新的2013版标准认证。以下是各个服务所对应的认证列表 促进信息行业安全，Proejct Zero 类比国内的乌云平台 不光抓自己的Bug 发现openssl heartbleed 发现widnows 0day 90天的修复期https://en.wikipedia.org/wiki/Project_Zero_(Google)https://googleonlinesecurity.blogspot.sg/2014/07/announcing-project-zero.html 爆光第三方组织的数据访问要求非技术，法律和政府层面。https://www.google.com/transparencyreport/userdatarequests/?hl=en 发布邮件传输加密报告https://www.google.com/transparencyreport/saferemail/?hl=en#region=142从技术层面，推出邮件这一网络基础应用的安全传输水平。 总结提供安全的服务，不是成本，而是产品的核心竞争力。安全，至关重要。","tags":[{"name":"security","slug":"security","permalink":"https://yangbo.tech/tags/security/"},{"name":"cloud","slug":"cloud","permalink":"https://yangbo.tech/tags/cloud/"}]},{"title":"Android 应用开发模拟器的选用","date":"2015-11-05T03:33:28.000Z","path":"2015/11/05/android-dev-emulator/","text":"在 Android 应用开发过程中无论是调试还是测试都要用到 Android 系统，有模拟器（虚拟机）和真机两种选择。 ABIABI（Applicaton Binary Interface），主要是 CPU 指令集和内存分页这两个最重要的硬件配置，现在已经运行在7个ABI：armeabi，armeabi-v7a (armeabi-v7a-hard)，arm64-v8a，x86，x86_64，mips 和 mips64。 真机真机在购买时已经选定了硬件ABI，ROM 的更新取决于 ROM 提供商， 就算解决了科学上网问题，Play Service 是否能正常运行也是个问题（国内 ROM 不会主动去通过 CTS 测试）。但做为 Andorid 开发者，真机还是必不可少的装备，Google Nexus系是首选，不必是最新的机型（除非做最新硬件适配），旧的硬件配置上应用性能没问题的话，更新的硬件应用性能自然更好。 模拟器Android SDKAndroid官方模拟器，基于 qemu，在 Android SDK 以 system image 展现。 特点： 更新快 有 Preview Channel Googel APIs 原生支持 play service缺点：基于 qemu 的虚拟机，慢！Tips使用 x86 的 System Images，省去 arm虚拟机到 x86物理机的指令转换开销。Genymotionhttps://www.genymotion.com基于 VirtualBox 的模拟器，专注于模拟器产品，还提供更多功能的商业支持。安装后运行： 特点： 基于不断更新的 VirtualBox，快! 更好用的模拟器控制（右边栏）。 缺点： 原生不支持 play service Android 版本支持慢 安装 play service下载 play service 相关 APK，注意选 x86，virtualbox 是 x86架构。http://opengapps.org/ 把下载的 zip 直接拖到运行的 genymotion 模拟器中就行了。 后记真机/官方模拟器/Genymotion 配合使用，各取所长。 如果引入了第三方库，导致应用不能正常安装或运行，检查引入第三方库的 ABI 支持。例如国内很多 SDK 没有x86的支持，在开发时就只能使用 arm ABI。","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"}]},{"title":"Android开发中处理 SVG 和 Material Design 相关的有小工具和链接","date":"2015-10-31T02:39:21.000Z","path":"2015/10/31/useful-tools-and-links-for-svg-and-material-design/","text":"SVGVectorDrawable 和 AnimatedVectorDrawable向前兼容支持 API14+，官方只支持 API21+。https://github.com/wnafee/vector-compat 将原始的 SVG 文件转换为 Android 的 XML 资源https://github.com/inloop/svg2android 将 SVG 中的 Circle 和Ellipse 转换为 Path Arshttp://complexdan.com/svg-circleellipse-to-path-converter/ 动态演示SVG 中的 Path Arcshttp://users.ecs.soton.ac.uk/rfp07r/interactive-svg-examples/arc.html Trello 提供的 Gradle Plugin，可将 SVG 资源单独存放，方便组织和管理https://github.com/trello/victor Material DesignMaterial调色盘https://www.materialpalette.com/ Materisl Design 图标大全https://materialdesignicons.com/ Google 的 Material Design 示例，是一个小猜谜应用https://github.com/googlesamples/android-topeka 另一个 Material Design 示例https://github.com/chrisbanes/cheesesquare Material Design 秀场https://www.materialup.com/ 更方便的使用 Material Deisign APIhttps://github.com/DenisMondon/material-design-library 让 Material Design 兼容 API22之前的 Android 版本http://rey5137.com/material/ Blogshttp://www.androiddesignpatterns.com/ https://halfthought.wordpress.com/","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"}]},{"title":"关于 Brillo 和 Weave， 开发者应该知道的","date":"2015-10-30T11:17:07.000Z","path":"2015/10/30/all-about-brillo-and-weave/","text":"背景 在 Google IO 2015中宣布的 Android for IoT – Brillo和配套的协议 Weave 终于要揭开神秘的面纱了。Google 在2014年1月以32亿美元收购了物联网公司 Nest Lab，其实最主要还是看中了 Nest 在物联网操作系统和低功耗传输协议方面的杰出成就，经过快2年的磨合和消化，推出了 Brillo 和 Weave。 Brillo万物互联网上的 Android（Android for IoT），从名称上就可以看出与 Android、Android Wear、Android Auto、Android TV不同，因为其可以运行的硬件最低配置公为32M内存和128M存储，是一个非常精剪的 Androd 运行时环境，不会有 ART，可以看成只运行Linux 内核和部分 Android 本地库的Android系统。 WeaveWeave 的前身是 Thread，是一种基于 IP-V6用来解决智能家居应用场景中的网络传输，跟Thread 相对应的是 BLE（Bluetooth Low Energy）和 Zigbee，由 Nest 发起，成员有 Samsung, ARM Holdings, Freescale, Silicon Labs, Big Ass Fans， Yale。。。熟悉 Android 应用开发的同学都知道 Android 中进行 BLE 通讯是非常的方便，所以对于 Weave，会提供更加方便的 API 供开发者使用。 PS：在 IO2015的 Nest 展位上和Nest 一位资深工程师聊天，提到为什么有了 BLE和 Zigbee，Nest还要开发一种新的通讯协议，他提到说由于 Nest 对于物联网的投入比较早，当时根本找不到一个合适的协议来满足Nest 的网络传输需要，那就自己动手，丰衣足食了，并且基于 IP-V6也是与其它协议有着明显的优势，对传输速率和功耗进行了最优化的平衡设计。 可以用来开发什么有嵌入式，物联网，智能家居，Android 应用领域开发者，都可以利用 Brillo和 Weave 这样的开发平台和开放协议来进行富有创新性的开发，让用户有更多的选择，真正做到 Android is Everywhere。 以前用户在选择物联网和智能家居时，所有数据都会依赖于某一个产品提供商，形成数据孤岛，通过Brillo，解藕了特定产品和系统，硬件和软件都可以肆意的各自创新，像 Android 手机百花齐放一样，Brillo 迅速的进入家庭应用场景。 由于 Android 的开放性，掌握 Android 开发技能的人也越来越多，配合 NDK 的开发来切入这些风口领域，获得更广阔的职业发展前景。 由于Brillo极低的运行硬件要求，以及 Android 内核丰富的硬件架构支持，从硬件的发展上会有更大的飞跃和更多的产品，从32M内存配置向上不断延伸。 通过 Weave 通信Brillo 原生支持 Weave，Brillo 推出了最新的 Android 肯定会集成 Weave 的支持，并且还会以某种容易发布安装的形式支持 Android 之前的版本。OnHub 路由器原生支持 Weave，通信可以不通过 Android 设备，利用路由器进行直接的云端交互。由于 Weave 基于 IP-V6，理论上来讲，iOS 和 WP 都有支持的可能性。 需要的开发准备申请开发者资格https://developers.google.com/brillo/?hl=en先申请，可以在第一时间收到开发相关的更新。 学习 Android NDKhttp://developer.android.com/tools/sdk/ndk/index.htmlBrillo 应该只允许运行 NDK 生成的 so 模块，对于 Android 应用开发者来讲需要学习或温习 NDK 相关的开发，而对于从事嵌入式开发的同学需要了解下 Android 的 Java 与 NDk 是如何协同工作的，NDK 是C\\C++的开发环境，可能与你之前的开发环境会有一些支持库不同，但相信可以很快上手。 工具Android Studio1.4已经集成 NDK 的下载，不用再单独下载并手动配置。 在独立的 SDK 管理界面还没有 NDK，可以看出 Android Studio 作为官方开发工具进一步集成的趋势，类似于 XCode，全部内部管理 SDK。 参考官方 Blog 公告http://googledevelopers.blogspot.sg/2015/10/building-brillo-iant-devices-with-weave_27.html公告中文版：http://chinagdg.org/2015/10/building-brillo-iant-devices-with-weave/ 视频简介墙外无广告版：https://youtu.be/2rPkbyyviGIhttps://youtu.be/uIIZD4KuIJM视频简介墙内插入广告版：http://v.youku.com/v_show/id_XMTM3MTMzNjM0OA==.htmlhttp://v.youku.com/v_show/id_XMTM3MTQyODI1Mg==.html","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"}]},{"title":"国内 Android SDK 更新不用科学上网了","date":"2015-10-29T10:45:51.000Z","path":"2015/10/29/android-sdk-ok/","text":"做 Android 开发的同学们，最近更新 Android SDK 发现都是不需科学上网，下载速度基本上可以利用全部带宽，刚开始以为是 GFW 抽风了，但一直稳定的更新，刚才 dig 了一下，所有下载流量已经解析到了北京机房。 可以不用再配置代理，也不会从 SDK 和 Android Studio 引入 AndroidGhost 了。 网络 dig运营商：上海长城宽带123456789101112131415161718192021222324 bin dig dl.google.com; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; dl.google.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 44633;; flags: qr rd ra; QUERY: 1, ANSWER: 12, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;dl.google.com. IN A;; ANSWER SECTION:dl.google.com. 22 IN CNAME dl.l.google.com.dl.l.google.com. 22 IN A 203.208.48.131dl.l.google.com. 22 IN A 203.208.48.128dl.l.google.com. 22 IN A 203.208.48.136dl.l.google.com. 22 IN A 203.208.48.137dl.l.google.com. 22 IN A 203.208.48.142dl.l.google.com. 22 IN A 203.208.48.135dl.l.google.com. 22 IN A 203.208.48.133dl.l.google.com. 22 IN A 203.208.48.129dl.l.google.com. 22 IN A 203.208.48.130dl.l.google.com. 22 IN A 203.208.48.132dl.l.google.com. 22 IN A 203.208.48.134 结论由于国内异常复杂的网络情况，导致 dl.google.com 的下载速度会有很大的差别，但终归是不需要科学上网来更新 SDK 了。","tags":[{"name":"Android","slug":"Android","permalink":"https://yangbo.tech/tags/Android/"}]},{"title":"15分钟，使用BigQuery和Google Sheets对Hacker News历史数据进行在线分析","date":"2015-10-25T07:53:07.000Z","path":"2015/10/25/using-bigquery-with-gas-on-hacker-news-dateset/","text":"Felipe Hoffa使用 Hacker News API将Hacker News的数据导出到了Big Query，https://bigquery.cloud.google.com/table/fh-bigquery:hackernews.comments 这是一个共享的表，BigQuery每天有1000次的免费查询额度，再利用Google Sheets来保存查询结果并进行数据可视化，实现一个低成本的在线大数据分析流程。 环境准备不需要安装任何软件，只要有一个Google Account。打开以下两个页面：https://bigquery.cloud.google.com/table/fh-bigquery:hackernews.commentshttp://g.co/sheetsGoogle Sheets不仅提供数据保存和可视化，还集成了Googel Apps Script，天然支持BigQuery查询。打开https://bigquery.cloud.google.com/table/fh-bigquery:hackernews.comments进行一次简单的测试查询12345678910111213SELECT a.month month, stories, comments, comment_authors, story_authorsFROM ( SELECT STRFTIME_UTC_USEC(time_ts, '%Y-%m') month, COUNT(*) stories, EXACT_COUNT_DISTINCT(author) story_authors FROM [fh-bigquery:hackernews.stories] GROUP BY 1) aJOIN ( SELECT STRFTIME_UTC_USEC(time_ts, '%Y-%m') month, COUNT(*) comments, EXACT_COUNT_DISTINCT(author) comment_authors FROM [fh-bigquery:hackernews.comments] GROUP BY 1) bON a.month=b.monthORDER BY 1 表中的记录数和表大小 查询数据新建一个Google Sheets命名为Play Hacker News With BigQuery 开启BigQuery支持点击Tools -&gt; Script Editor...，打开Google Apps Script编程界面。 点击Resouces -&gt; Advanced Google Services...，会先弹出保存保存项目对话框，输入项目名称，点击OK。 启用BigQuery支持。 点击Google Developers Console链接，在控制台上启用BigQuery。 启用API，并记录下URL中的Project ID（纯数字，图中被涂部分），获取数据时会用到。 获取数据使用以下Googel Apps Script代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function runQuery() &#123; // Replace this value with your Google Developer project number (It is really a number. // Don't confuse it with an alphanumeric project id) var projectNumber = '替换为前边提到的ProjectID'; if (projectNumber.length &lt; 1) &#123; var errMsg = \"You forgot to set a project number - So no BQ for you!\"; Logger.log(errMsg); Browser.msgBox(errMsg); return; &#125; var sheet = SpreadsheetApp.getActiveSheet(); var sql = 'SELECT a.month month, stories, comments, comment_authors, story_authors FROM (SELECT STRFTIME_UTC_USEC(time_ts, \\'%Y-%m\\') month, '+ 'COUNT(*) stories, EXACT_COUNT_DISTINCT(author) story_authors FROM [fh-bigquery:hackernews.stories] GROUP BY 1 ) a JOIN '+ '(SELECT STRFTIME_UTC_USEC(time_ts, \\'%Y-%m\\') month, COUNT(*) comments, EXACT_COUNT_DISTINCT(author) comment_authors '+ 'FROM [fh-bigquery:hackernews.comments] GROUP BY 1 ) b ON a.month=b.month ORDER BY 1;'; var queryResults; // Inserts a Query Job try &#123; var queryRequest = BigQuery.newQueryRequest(); queryRequest.setQuery(sql).setTimeoutMs(100000); queryResults = BigQuery.Jobs.query(queryRequest, projectNumber); &#125; catch (err) &#123; Logger.log(err); Browser.msgBox(err); return; &#125; // Check on status of the Query Job while (queryResults.getJobComplete() == false) &#123; try &#123; queryResults = BigQuery.Jobs.getQueryResults(projectNumber, queryJob.getJobReference().getJobId()); &#125; catch (err) &#123; Logger.log(err); Browser.msgBox(err); return; &#125; &#125; // Update the amount of results var resultCount = queryResults.getTotalRows(); var resultSchema = queryResults.getSchema(); //get cloumn header // Append the headers. var headers = queryResults.schema.fields.map(function(field) &#123; return field.name; &#125;); sheet.appendRow(headers); var resultValues = new Array(resultCount+1); var tableRows = queryResults.getRows(); // Iterate through query results for (var i = 0; i &lt; tableRows.length; i++) &#123; var cols = tableRows[i].getF(); resultValues[i] = new Array(cols.length); // For each column, add values to the result array for (var j = 0; j &lt; cols.length; j++) &#123; resultValues[i][j] = cols[j].getV(); &#125; &#125; // Update the Spreadsheet with data from the resultValues array, starting from cell A1 sheet.getRange(2, 1, resultCount, tableRows[0].getF().length).setValues(resultValues); Browser.msgBox(\"Yo yo! We are done with updating the results\");&#125;//// Insert our customize menu item//function onOpen() &#123; var sheet = SpreadsheetApp.getActiveSpreadsheet(); var menuEntries = [ &#123;name: 'Run Query', functionName: 'runQuery'&#125; ]; sheet.addMenu('BigQuery Example', menuEntries);&#125;; 保存，在方法下拉框中选择runQuery，点击运行（小三角图标）。 第一次运行需要一次性授权 授权完成，再点击一次运行。运行完成，切换到新的Google Sheet页面，查看结果。 使用图表利用Google Sheets提供的强大报表功能，让我们查询出来的数据变得更加具有表现力。直接点击右下角的Explorer 浏览自动生成的报表，选择喜欢的插入入到文档中。 对报表再进行进一步的定制 最终的效果： Play Hacker News With BigQuery的链接，可以自由打开，先看下效果。https://docs.google.com/spreadsheets/d/1iMedOlxn_CBrvYERvap1kIz2l8mT2cqFag11OrmnIX4/edit?usp=sharing 总结可以看出，对于大概4G的数据量进行BigQuery查询分析，是非常的快，并且利用Google Sheets进行结果展示，让大数据在云端飞起来。希望看到更多利用大数据分析的应用来丰富我们的生活。 后记BigQuery的免费使用额度为：10000个查询每天，1000G存储每月。","tags":[{"name":"cloud","slug":"cloud","permalink":"https://yangbo.tech/tags/cloud/"},{"name":"big data","slug":"big-data","permalink":"https://yangbo.tech/tags/big-data/"}]},{"title":"利用Google Maps API预测未来","date":"2015-10-24T08:43:47.000Z","path":"2015/10/24/predict-future-travel-time/","text":"引子大数据，云计算。。。这些词汇越来越多的出现在开发者和普通人的语境里，对于这些技术，不同的角度可以有不同的解读，但目的应该是统一明确的：存储分析利用过去的数据，当然是越多越好，也就是大数据，以最快的计算速度和最低的计算成本来组织、处理、分析这些数据（云计算），为解决当下的问题提供依据，如果还能够预测未来，让资源配置更优就更好了。 路线规划在现实世界中，人、财、物时时刻刻都在流动，为了达到最优路径，路线规划就成了最本质最普适的计算需求。有需求就有相应的产品，以下是Google、百度、高德这三家地图市场占有率前三的路线规划功能： 对比相同点，三个地图中都有相应的路线规划功能，指定出发地点和到达地点，提供多条路径供选择。不同点，在Google Maps中，对于路线规划多了指定出发时间的功能，在截图中箭头所指位置。使用Google Maps，指定未来时间，就可以回答： 几点出发可以在下午3点前到达机场？ 我们的服务人员几点钟可以到达客户现场？ 下周二可以安排走访四个场地吗？。。。。。。 预测未来指定出发时间，看似简单的一项功能，后边却包含了调用分析整个Google Maps累积的海量历史交通数据，利用Google的计算能力，在不影响API返回速度的提前下，对未来进行预测。 使用APIGoogle Maps API是Google Maps的技术支持，预测未来的这个功能，在API中也可以调用来让我们的应用，不论是LBS还是O2O，都变得更加智能。可以在Direction和Matrix Distance中指定departure_time:https://developers.google.com/maps/documentation/directions/introhttps://developers.google.com/maps/documentation/distance-matrix/intro输入参数：departure_time,从1970/01/01,00:00:00开始的整数，单位是s。 Bonus还有一个配置预测的参数，没有在API文档中列出来，那就是traffic_model，用来手工影响预测结果。best_guess，默认值。pessimisticoptimistic一图胜千言： 典型用途企业级应用 消费级应用 使用授权由于这个功能要消耗大量的计算资源，现在只在Google Maps API for Work中指定departure_time才会有效。 update20151111两个在线示例 http://mapsptt.appspot.com/getdirectionshttp://mapsptt.appspot.com/getdirections?origin=SFO,%20San%20Francisco,%20CA,%20United%20States&amp;destination=Googleplex,%20Amphitheatre%20Parkway,%20Mountain%20View,%20CA,%20United%20States&amp;client=gme-addictive&amp;departure_time=1457254000 http://mapsptt.appspot.com/getdirections?origin=SFO,%20San%20Francisco,%20CA,%20United%20States&amp;destination=Googleplex,%20Amphitheatre%20Parkway,%20Mountain%20View,%20CA,%20United%20States&amp;client=gme-addictive&amp;departure_time=1467254000 http://mapsptt.appspot.com/getdistancehttp://mapsptt.appspot.com/getdistance?origin=SFO,%20San%20Francisco,%20CA,%20United%20States&amp;destination=Googleplex,%20Amphitheatre%20Parkway,%20Mountain%20View,%20CA,%20United%20States&amp;client=gme-addictive&amp;departure_time=1457254000 http://mapsptt.appspot.com/getdistance?origin=SFO,%20San%20Francisco,%20CA,%20United%20States&amp;destination=Googleplex,%20Amphitheatre%20Parkway,%20Mountain%20View,%20CA,%20United%20States&amp;client=gme-addictive&amp;departure_time=1467254000 20151113另外两个示例 https://commutetraffic.appspot.com/ptt-directions.html声明 direction service12345678910111213141516171819202122232425262728293031323334353637383940414243// Declare the Directions Servicevar directionsService = new google.maps.DirectionsService();/*** Use the Places Autocomplete Place IDs for the origin and* destination to reduce chances of errors.* The departure time is in milliseconds and MUST be in the future.* Travel mode is Driving.*/var request = &#123; origin: &#123; placeId: \"ChIJyYfhZ79ZwokRMtXcL6CYxkA\" &#125; &#125;, destination: &#123; placeId: \"ChIJvwJZrWH4wokRNBcFMQ0ohIE\" &#125;, travelMode: google.maps.TravelMode.DRIVING, drivingOptions: &#123; departureTime: new Date(1447621200000), trafficModel: google.maps.TrafficModel.BEST_GUESS &#125; 发送请求处理回调123456789101112131415161718192021222324252627directionsService.route(request, function(result, status) &#123; // Check to see if the Service responded as expected if (status == google.maps.DirectionsStatus.OK) &#123; var routesLegs = result.routes[0].legs[0]; var durationText = routesLegs.duration.text; var durationInTrafficText = routesLegs.duration_in_traffic.text; var duration = routesLegs.duration.value; var durationInTraffic = routesLegs.duration_in_traffic.value; // Create a \"Traffic Factor\" score between typical and predicted travel times var trafficFactor = (durationInTraffic / duration);&#125; else &#123; // Alert why the Directions Service Request failed. alert('Directions request failed due to ' + status);&#125; 返回结果中的 leg 数据1234567891011121314151617181920\"legs\": [ &#123; \"duration\": &#123; \"text\": \"25 mins\", \"value\": 1471 &#125;, \"duration_in_traffic\": &#123; \"text\": \"28 mins\", \"value\": 1687 &#125; ... https://commutetraffic.appspot.com/ptt-distanceMatrix.html和上个示例一样，使用 Distance Matrix API 参考 关于如何实现预测： http://onlinepubs.trb.org/Onlinepubs/IDEA/FinalReports/Reliability/FINALREPORTL15A%20.pdf http://people.orie.cornell.edu/woodard/WoodNogiKoch15.pdf","tags":[{"name":"google maps api","slug":"google-maps-api","permalink":"https://yangbo.tech/tags/google-maps-api/"}]},{"title":"找回Mac OSX El Captian默认隐藏的Dashboard","date":"2015-10-20T12:43:47.000Z","path":"2015/10/20/re-enable-osx-el-captian-dashboard/","text":"升级到最新的10.11，出现了几个不爽的地方。 TotalTermial停止更新，不支持10.11。没关系，换用iTerm 2。 XtraFinder不支持10.11。找到了Snap，商店下载。App Store热键唤起Finder，并且可直接不用再点击Dock上的图标进行应用切换，直接使用快捷键Command+1,Command+2。。。，够犀利。比之前提高了效率。 Dashboard被隐藏了发现桌面换到最左边没有Dashboard了，不能接受这个Change，也没有什么说明。万能的Google，可以在Mission中手动启用。 回来了！","tags":[{"name":"osx","slug":"osx","permalink":"https://yangbo.tech/tags/osx/"}]},{"title":"在Android Studio中发布Library到jCenter公共仓库","date":"2015-10-19T14:03:01.000Z","path":"2015/10/19/distribute-android-library-to-jcetner/","text":"引论在Android开发，关于aar你应该知道的一文中掌握了如何引用本地的aar，更多情况下我们是直接从网络上获取公开的第三方库来进行开发，而这个网络位置就是jCenter，在gradle中使用：123repositories &#123; jcenter() &#125; jCenter是Bintray提供的公开下载服务，使用自身开发的artifactory开源应用搭建，后绪会介绍如何使用artifactory来搭建团队内部的私有仓库。 什么是jCenterartifactory其实就是带有版本管理的文件服务器，基本功能和FTP服务相同，公开服务是jCenter，还提供托管的私有仓库，同github一样，提供企业收费服务，更多的功能，更快的下载速度。 开发者先将Library提交到自己的私有库，再同步到公共jCenter库，其它开发就可以简单的来添加依赖了：123dependencies &#123;compile 'com.squareup.retrofit:retrofit:1.9.0'&#125; 在这个架构图中，还有一个maven central和ivy仓库，都提供类似的下载托管功能，但要么太老了，要么太少人使用。 再说下maven仓库引用的格式1compile 'com.squareup.retrofit:retrofit:1.9.0' 定义为：1GROUP_ID:ARTIFACT_ID:VERSION GROUP_ID:com.squareup.retrofit，组，方便公司或团队进行逻辑上的管理。ARTIFACT_ID:retrofit，Library名称。VERSION:1.9.0，Library指定版本。Module中的完整依赖：12345678910dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.0.1' compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.0' compile 'com.squareup.okhttp:okhttp:2.0.0' compile 'com.squareup.retrofit:retrofit:1.9.0' compile 'com.google.code.gson:gson:2.3' compile 'io.reactivex:rxjava:1.0.11'&#125; 在依赖中不要使用动态版本号Gradle中支持使用+来引用动态版本，人生苦短，不要使用它！1compile 'com.android.support:appcompat-v7:23.0.+' 任何依赖的改变，你都应该被显式的知晓，以便知道自己的项目中有除了自己的代码，依赖都发生了哪些变化。这个+，会大大增加你代码的不确定性！！理由： 依赖也是你应用的一部分，任何变更，都要知道。 每个人的开发不尽相同，在你的机器上可以运行，在其它机器上可能运行不起来，因为依赖版本不一样。 同样的，在你的机器上也会出现由于版本不同而运行失败，昨天好好的，今天怎么就跑不进来了？那是因为早晨另一个项目中升级了本地依赖！ 版本回滚，显示的版本号支持精准的回滚。 不要自动依赖升级，任何依赖更新都有可能引入安全问题，回到第一点，任何变更，都要知道，升级要验证。 不要犯懒，依赖管理很重要，程序开发过程就是消除不确定性的过程，一个+的犯懒，可能会让你和项目消耗极大的精力。不要假设依赖总是好的，是人都会犯错误，任何的开发在减少不确定性的时候也同时在引入新的不确定性。 PS：jCenter不只支持maven和gradle,还提供Yum, Apt, Vagrant and Docker。 Android Studio为什么使用jCenterJava的构建工具从ant,maven到现在的gradle，依赖包仓库也经历了maven central和jCenter，同样Android Studio中的Gradle默认仓库也经历了先使用maven central后来又升级到了jCenter的过程，简单来说： jCenter完全兼容maven，maven central中有的，jCenter有，maven central中没有的，jCenter也有，是maven central的超集，现在是全球包含Java和Android开源项目最大的仓库。 使用CDN加速下载，基于https安全传输，Google最喜欢的传输方式，杜绝在传输过程中偷梁换柱，造成类似xcodeghost的惨剧。 包的上传和管理操作更简便，流程更优（让包开发者更懒） 支持一键同步到maven central（尊重历史，还有什么理由不用） 让gradle使用maven central（团队内部库/被jCenter拒了/偷懒不进jCenter）：123repositories &#123; mavenCentral() &#125; 还有一种情况是使用私有Maven仓库：12345repositories &#123; maven &#123; url \"http://dl.bintray.com/alphayang/maven\" &#125;&#125; 发布到jCenter准备帐户在https://bintray.com上注册，可使用github登陆。 创建私有Maven仓库 添加Package新建包 包名，License和代码码本管理必填。 Andorid Studio中的工作New ProjectFile -&gt; New Project New Project默认都是先创建一个Application Module，正常创建就好，正好可以用来做Library的Demo App。 New Module创建Library ModuleFile -&gt; New Module 新建的Library与正常的Application最大区别是module build.gradle中是apply plugin: ‘com.android.library’ 而不是 apply plugin: ‘com.android.application’。在这里发挥才智实现功能。完整的Project Structure: 添加上传的Gradle脚本支持在weatherlib/build.gradle中：12345678910apply plugin: 'com.novoda.bintray-release' // 这一行必须添加在java / com.android.library plugin之后buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.novoda:bintray-release:0.3.4' &#125;&#125; 在weatherlib/build.gradle中添加Package信息，当然这里的信息都是Package相关的，使用时要改成自己的:12345678publish &#123; userOrg = 'alphayang' groupId = 'com.geekdev' artifactId = 'weatherlib' publishVersion = '0.2.5' desc = 'Simple ForecastIO client' website = 'https://github.com/alphayang/WeatherLibe'&#125; 发布⌘F9，上传前Build下代码，确保正常。然后在Terminal Panel中执行：1$ ./gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false BINTRAY_USERNAME和BINTRAY_KEY在bintry profile页面获取，注意username不是name。https://bintray.com/profile/edit 发布成功在bintray界面： 上传的版本： 上传的文件列表： 添加到jCenter公共仓库一键添加到jCenter 添加到jCenter公共仓库需要简单的人工审核 等几个小时，会有邮件通知审核结果。这个审核是必要的，公共仓库还是要有人把守，要不然鱼龙混杂，不好用了。 OK了，你的包已经自动同步到jCenter，任何人可以公开获取使用了。 1compile 'com.geekdev:weatherlib:0.2.5' http://jcenter.bintray.com/里有jCenter全部的公开库。 总结jCenter是现在最好用公开Android库，对于使用还是使用者都提供了最好的使用体验。BinTray开发一个artifactory提供三种形态：个人私有库，公开社区库和商业库，保证了整个业务的良性发展，也是这一类开发者服务最好的商业模式。 后记由于Maven Central已经老去，从jCenter同步到Maven Central的步骤本文不做介绍了（同理ivy）。 ReferenceAndroid Studio – Migration from Maven Central to JCenterbintray-release","tags":[{"name":"Andorid","slug":"Andorid","permalink":"https://yangbo.tech/tags/Andorid/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangbo.tech/tags/Gradle/"},{"name":"Andorid Studio","slug":"Andorid-Studio","permalink":"https://yangbo.tech/tags/Andorid-Studio/"}]},{"title":"如何在Android Studio Project中集中管理Android Support Library依赖","date":"2015-10-18T13:33:52.000Z","path":"2015/10/18/support-library-group-in-gradle/","text":"问题有时候一个Project中包含了好几个module，每个module都要用到Android Support Library，每当升级Support Library时要改好几处，相当麻烦。12345678root --module1 --build.gradle --module2 --build.gradle --module3 --build.gradle --build.gradle 利用Gradle的apply from进行拆分Gradle基于Groovy脚本语言，本身使用Plugin机制提供扩展和模块化，也支持文件间的引用包含apply from，跟C的include,Java的import一样，那么我们就把Android Support Library相关的部分单独提取到root/gradleScript/dependencies.gradle中。12345678910root --gradleScript --dependencies.gradle --module1 --build.gradle --module2 --build.gradle --module3 --build.gradle --build.gradle 应用在root/gradleScript/dependencies.gradle中：12345678910111213ext &#123; //Version supportLibrary = &apos;22.2.0&apos; //Support Libraries dependencies supportDependencies = [ design : &quot;com.android.support:design:$&#123;supportLibrary&#125;&quot;, recyclerView : &quot;com.android.support:recyclerview-v7:$&#123;supportLibrary&#125;&quot;, cardView : &quot;com.android.support:cardview-v7:$&#123;supportLibrary&#125;&quot;, appCompat : &quot;com.android.support:appcompat-v7:$&#123;supportLibrary&#125;&quot;, supportAnnotation: &quot;com.android.support:support-annotations:$&#123;supportLibrary&#125;&quot;, ]&#125; 在root/build.gradle中：123456789101112buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.3.0&apos; &#125;&#125;// 引用gradle文件apply from: &apos;gradleScript/dependencies.gradle&apos; 在module/build.gradle中使用：12345dependencies &#123; //...... compile supportDependencies.appCompat compile supportDependencies.design&#125; 总结Gradle利用Grovvy，其动态脚本语言的特性，跟JavaScript一样，运行时将所有Plugin和自写代码载入到一个上下文中，Plugin可以看成是Groovy的一个jar包，独立出来的gradle文件是一个只有一个文件的jar包，其自身的扩展性潜力无限，这也是Android Studio选择Gradle Build System的原因。","tags":[{"name":"Andorid","slug":"Andorid","permalink":"https://yangbo.tech/tags/Andorid/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangbo.tech/tags/Gradle/"},{"name":"Andorid Studio","slug":"Andorid-Studio","permalink":"https://yangbo.tech/tags/Andorid-Studio/"}]},{"title":"Android开发，关于aar你应该知道的","date":"2015-10-17T11:45:17.000Z","path":"2015/10/17/all-about-aar/","text":"背景在软件工程中，分治是最基本的设计原理，就如同现实中的砖、瓦、钢筋、水泥一样，模块化、组件化的分工，让我们整个软件世界变得井井有序，丰富多彩。 Java jar在Java开发中，添加组件简单的以添加jar文件依赖为途径，jar有两个含义： jar文件格式：Java Archive，就是zip文件格式，文件名后缀是jar，包含了java class，metadata，资源（文本、图片等）。 Java archive tool: JDK中的工具，用来生成jar包的工具。 jar在Android开发中的不足在Android应用资源中，Java Source，Resouce以及所需的so文件和jar包，用jar格式可以很好的处理Java Source,但对于目录比较复杂的Android Res目录，二进制依赖so文件和jar包则显得的乏力。当你收到一个第三方SDK zip包，要添加到自己的项目中，解压后是一个jar包和一堆文件夹，不停的复制粘贴甚至解决冲突的时候，心里肯定开始不满意这血吸虫组件分发方式了。 aar什么是aar为了解决Android开发中组件引用的问题，引入aar格式。也是简单的zip格式。定义：The ‘aar’ bundle is the binary distribution of an Android Library Project.Zip包中的内容有： /AndroidManifest.xml (mandatory) /classes.jar (mandatory) /res/ (mandatory) /R.txt (mandatory) /assets/ (optional) /libs/*.jar (optional) /jni//*.so (optional) /proguard.txt (optional) /lint.jar (optional)其中，R.txt是aapt –output-text-symbols命令的输出。 生成aar在Android Studio1.4中，New project，先默认新建一个Applicaton module，接后File &gt; New &gt; New Module，选择Androd Library &gt; Next，指定Library Name和Module Name。 新建的Library与正常的Application最大区别是module build.gradle中是apply plugin: ‘com.android.library’ 而不是 apply plugin: ‘com.android.application’. Build &gt; Make project(⌘F9),自动生成aar文件。12345| build | outputs | aar | mylibrary-debug.aar | mylibrary-release.aar 使用aaraar可通过以下三种方式引入到项目中： 公共Maven仓库 私有Maven仓库 复制粘贴aar文件前两种引入方式涉及到Gradle发布Library到Maven，另文介绍。重点介绍第三种方式： 把aar粘贴到要引入库的Application Module/libs目录下，如没有libs目录，创建就好。注意要在Application Module根目录下，不是Project根目录下。 在Application Module/build.gradle中添加12345repositories &#123; flatDir &#123; dirs 'libs' &#125;&#125; flatDir repositories用来声明文件目录做为依赖库，’libs’路径是build.gradle的相对路径，目录名称可以任意，也可以同时声明多个dirs。 在Application Module/build.gradle中添加依赖123dependencies &#123; compile(name:'mylibrary-debug', ext:'aar')&#125; 关于AndroidManifest.xml合并在上文中看到aar文件中还包含了库中的AndroidManifest.xml文件，但是最终应用APK中只能有一个AndroidManifest.xml，就涉及到应用AndroidManifest.xml和所有库AndroidManifest.xml的合并。 合并顺序： 1.与Produt flavors和build types指定的清单文件 2.application module的主清单文件 3.library module的清单文件 大多数情况下合并不会造成什么问题，如果发现合并后出现了问题： 检查最终的AndroidManifest.xml 检查合并报告（app\\build\\outputs\\logs\\），日志文件的格式和内容 后记本文中所用的项目代码托管在github。 引用 AAR File Formathttp://tools.android.com/tech-docs/new-build-system/aar-format Manifest merging user guidehttp://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger","tags":[{"name":"Andorid","slug":"Andorid","permalink":"https://yangbo.tech/tags/Andorid/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangbo.tech/tags/Gradle/"},{"name":"Andorid Studio","slug":"Andorid-Studio","permalink":"https://yangbo.tech/tags/Andorid-Studio/"}]},{"title":"加速Android Studio中的Gradle Build","date":"2015-10-16T06:45:17.000Z","path":"2015/10/16/speed-up-android-studio-build/","text":"问题Gradle Sync或Build越来越慢，已经快不能忍受了，硬件配置并不差呀！ 分析两个方面：1，项目越来越大,依赖越来越多；2，Gradle本身为了兼容配置太中庸。 解决办法针对1，将公用代码分离出来，以aar格式导出，使用时加本地aar或网络引用 。2，对Gradle进行优化配置。 升级gradle版本，此法向前向后兼容现在Android Studio默认的Gradle版本为2.4，而最新的Gradle版本为2.7，稳妥起见，升级到次新版2.6 build.gradle添加下边的代码到project的build.gradle123task wrapper(type: Wrapper) &#123; gradleVersion = '2.6'&#125; 在Android Studio的Terminal中运行1./gradlew wrapper 或在Android Studio的Gradle Panel展开Project-&gt;Project(root)-&gt;Tasks-&gt;other,找见wrapper任务，单击执行。 Project属性快捷键⌘+;打开项目属性，更新Gradle版本 配置GradleGradle运行期环境增强配置在Project根目录下的gradle.properties文件中添加1234org.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.jvmargs=-Xmx2gorg.gradle.java.home=/path/to/jvm Daemon,守护进程，避免冷启动，Andorid Studio已默认开启，添加确保在Terminal下使用gradlew也使用。更多http://gradle.org/docs/current/userguide/gradle_daemon.html#when_should_i_not_use_the_gradle_daemonParallel,并发，充分利用硬件的多核性能，可能会让你的项目Build失败，那是因为项目结构没有解藕。更多http://gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projectsjvmargs，grovvy寄宿在jvm中运行，加大jvm的内存，给gradle更大的展现空间，比如-Xmx将heap size加大到2g，java.home，使用与项目不同的java运行时，通常是Android开发使用JDK7，Gradle使用JDK8获得更好的性能。Gradle的完整配置可以参考http://gradle.org/docs/current/userguide/userguide_single.html#sec:gradle_configuration_properties 这个配置同样可做为全局配置，添加到 ~/.gradle/gradle.properties Gradle Build增量模式在Module的build.gradle中添加123456android&#123;... dexOptions &#123; incremental true &#125;&#123; 指定APK的DEX环节使用增量模式。 后记还不够快，你该升级你的硬件设备了！ One more thingGradle wrapper是如何工作的？gradle作为一个独立的软件，之前都需要自己安装，像上边的过程中怎么只改了下数字，就全部搞定了呢？如下图，Android Studio的Project中除了build.gradle,gradle.settings,gradle.properties之外，还有一个gradle目录。 这个jar文件只是一个钩子，每个project都有，调用功能时，由钩子调用实际的本地应用，位置如下：123Downloads ls ~/.gradle/wrapper/dists/gradle-gradle-1.8-bin/ gradle-2.2.1-all/ gradle-2.4-bin/ gradle-2.6-all/gradle-2.2-all/ gradle-2.4-all/ gradle-2.5-all/ gradle-2.7-all/ 而这些版本是全局共享的，我们升级版本，Android Studio会自动下载本地没有的版本到这里。 更新20151205Gradle 最新版本为2.9升级 Android Plugin12345buildscrpt &#123; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.5.0&apos; &#125;&#125; 开发使用SDK=2112345678910android &#123; productFlavors &#123; dev &#123; minSdkVersion 21 &#125; prod &#123; minSdkVersion 14 &#125; &#125;&#125; 原理：API&gt;=21，使用 ART，在 Build 时只做 class to dex，不做 mergeing dex，省时间。","tags":[{"name":"gradle","slug":"gradle","permalink":"https://yangbo.tech/tags/gradle/"}]},{"title":"Android Studio中Gradle依赖树查看","date":"2015-10-15T02:24:23.000Z","path":"2015/10/15/gradle-dependence-tree/","text":"问题在Andorid Studio中查看Gralde添加的依赖时，只有平行的一级，看不出任何从属关系，特别是出现依赖冲突的时候，在build.gralde中根据没有添加的包，怎么会出现冲突呢？真让人摸不着头脑。 参考在maven中提供了树形依赖来清晰的查看依赖关系1mvn dependency:tree -Dverbose -Dincludes=commons-collections 结果：123456789[INFO] [dependency:tree][INFO] org.apache.maven.plugins:maven-dependency-plugin:maven-plugin:2.0-alpha-5-SNAPSHOT[INFO] +- org.apache.maven.reporting:maven-reporting-impl:jar:2.0.4:compile[INFO] | \\- commons-validator:commons-validator:jar:1.2.0:compile[INFO] | \\- commons-digester:commons-digester:jar:1.6:compile[INFO] | \\- (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 2.0)[INFO] \\- org.apache.maven.doxia:doxia-site-renderer:jar:1.0-alpha-8:compile[INFO] \\- org.codehaus.plexus:plexus-velocity:jar:1.1.3:compile[INFO] \\- commons-collections:commons-collections:jar:2.0:compile 解决办法在Gralde这里也可以达到相同的效果 Gradle Panel在Gradle Panel中打印,Project和Module都支持。 运行输出：12345678910111212:02:24 PM: Executing external task 'androidDependencies'...:core:androidDependenciesdebug+--- LOCAL: libGoogleAnalyticsV2.jar+--- LOCAL: CWAC-SackOfViewsAdapter.jar+--- LOCAL: ushahidi_sdk-1.1.jar+--- com.android.support:support-v4:22.2.0| \\--- LOCAL: internal_impl-22.2.0.jar\\--- com.google.android.gms:play-services:8.1.0 +--- com.google.android.gms:play-services-ads:8.1.0 | +--- com.google.android.gms:play-services-basement:8.1.0...... 项目层添加gradle脚本在项目根目录下build.gradle中添加123subprojects &#123; task allDeps(type: DependencyReportTask) &#123;&#125;&#125; 在Android Studio Terminal下运行1./gradlew allDeps 可以得到全部依赖的树形结构12345678androidJacocoAnt - The Jacoco ant tasks to use to get execute Gradle tasks.\\--- org.jacoco:org.jacoco.ant:0.7.4.201502262128 +--- org.jacoco:org.jacoco.core:0.7.4.201502262128 | \\--- org.ow2.asm:asm-debug-all:5.0.1 +--- org.jacoco:org.jacoco.report:0.7.4.201502262128 | +--- org.jacoco:org.jacoco.core:0.7.4.201502262128 (*) | \\--- org.ow2.asm:asm-debug-all:5.0.1 \\--- org.jacoco:org.jacoco.agent:0.7.4.201502262128 打出出来的结果很长，也有很多重复的部分，由于不同的配置。可以指定配置1./gradlew allDeps --configuration default 使用Andorid Studio gradle view plugingradle view plugin体现了Android Studio基于Intellij平台的优势。安装：Android Studio-&gt;Preferences-&gt;Plugins-&gt;Browser Repositories,搜索Gradle View安装。（如果显示或下载有问题，科学上网，你懂的）结果： 结论建议多种方法配合使用，脚本可搜索，但是每个项目需要自行添加，插件一劳永逸，可视化操作，但不支持搜索，当你要解决依赖冲突时，搜索是最快发现问题的途径。","tags":[{"name":"gradle","slug":"gradle","permalink":"https://yangbo.tech/tags/gradle/"}]},{"title":"Java，ruby，python包管理使用国内镜像","date":"2015-10-14T02:24:23.000Z","path":"2015/10/14/package-manage-for-china/","text":"针对国内的网络，下载依赖包是很头疼的事，下面是我的tweak: Java Maven使用oschina提供的maven库。 gradle中 1234// 设置 maven 库地址repositories &#123; maven &#123; url 'http://maven.oschina.net/content/groups/public/' &#125;&#125; Ruby Gemrubygems.org存放在s3上的资源极由于国内网络原因极不稳定，gem install rack或bundle install时让人抓狂。使用taobao提供的gem源 1234567$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org$ gem install rails 使用bundle时,在Gemfile里指定source: 1source 'http://ruby.taobao.org/' rvm使用taobao源，提供ruby安装速度 1sed -i .bak 's!ftp.ruby-lang.org/pub/ruby!ruby.taobao.org/mirrors/ruby!' $rvm_path/config/db Python Pipdouban大量使用了python，也对社区做贡献，速度快。直接使用 1pip install -i http://pypi.douban.com/simple simplejson 全局使用vi ~/.pip/pip.conf 12[global]index-url = http://pypi.douban.com/simple","tags":[{"name":"tools","slug":"tools","permalink":"https://yangbo.tech/tags/tools/"}]}]